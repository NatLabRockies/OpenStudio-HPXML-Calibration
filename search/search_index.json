{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Generate an HPXML model of home energy use, calibrated to utility data.</p> <p>Nearly everyone will interact solely with the command line interface</p> <p>Custom workflows can be built using the classes &amp; methods. See the <code>Code Documentation</code> section for more information. For advanced users only.</p> <ul> <li><code>openstudio-hpxml-calibration --help</code></li> <li>Or the short version: <code>oshc -h</code></li> </ul>"},{"location":"#required-inputs","title":"Required inputs","text":"<ul> <li>Measured consumption data:<ul> <li>In the HPXML model, or</li> <li>A CSV file of utility data</li> </ul> </li> <li>A config file specific to the home being calibrated</li> </ul>"},{"location":"#usage-instructions","title":"Usage instructions","text":"<ol> <li> <p>Use the <code>calibrate</code> command of the app. Required parameters:</p> <ul> <li>path to hpxml file</li> <li>path to the config file for that home</li> </ul> <p><code>oshc calibrate --hpxml-filepath path/to/asdf.xml --config-filepath path/to/qwer.yml</code></p> </li> <li> <p>Optional parameters for the <code>calibrate</code> command:</p> <ul> <li>path to csv of consumption data (if using that technique)</li> <li>path to output-dir: to save in a custom location</li> <li>num-proc: integer number of processor cores to use for parallel simulations</li> <li>save-all-results: flag to capture all intermediate steps. Useful for debugging</li> <li>verbose: flag to enable more verbose logging during operation. Can be repeated for increased output</li> </ul> <p><code>oshc calibrate --hpxml-filepath path/to/asdf.xml --config-filepath path/to/qwer.yml --csv-bills-filepath path/to/bcde.csv --output-dir path/to/test_output --num-proc 8 --save-all-results --verbose --verbose</code></p> </li> </ol>"},{"location":"#outputs","title":"Outputs","text":"<ul> <li>A folder for each generation of the calibration search, with the best individual HPXML model of the generation.</li> <li><code>logbook.json</code> which captures the outputs at each generation, including the value choices of the best individual, the simulation results for that individual, and the corresponding error values.</li> <li><code>best_individual.xml</code> model, the calibrated model which meets the acceptance criteria set in the config file.</li> <li>Plots showing weather normalization (if using detailed calibration) and calibration search.</li> </ul>"},{"location":"bpi2400/","title":"BPI 2400 compatibility","text":"<p>We compare our compatibility with BPI 2400 via the flowchart in Figure 1 of the BPI-2400-S-2015 v.2 standard.</p> Meets To do Utility bill criteria (almost)\u200b (3.2.2) Utility bill criteria Detailed Calibration (3.2)\u200b 3.2.2.D Simplified Calibration (3.3)\u200b 3.2.2.E Normalize consumption to weather (3.2.1)\u200b 3.2.2.F.b\u200b Meets acceptance criteria (3.2.3, 3.3.2)\u200b Input constraints (3.4)\u200b Apply retrofits and compare with calibrated model (4.1, 4.2)"},{"location":"inputs/","title":"Inputs","text":""},{"location":"inputs/#utility-consumption","title":"Utility consumption","text":"<p>If not included in the hpxml already, we can add it from a csv:</p> <ul> <li>An example file can be found at tests/data/test_bills.csv</li> <li>It has this format:</li> </ul> Consumption StartDateTime EndDateTime UnitofMeasure FuelType 1000 2/1/23 2/28/23 kWh electricity 1000 3/1/23 3/31/23 kWh electricity 120 1/1/23 1/31/23 therms natural gas"},{"location":"inputs/#config-file","title":"Config file","text":"<ul> <li>The default config can be found at src/openstudio_hpxml_calibration/default_calibration_config.yaml</li> <li>The default file should not be altered. Create an override config specific for each home</li> <li>An example override config can be found at tests/data/test_config.yaml</li> </ul>"},{"location":"search_config/","title":"Search Algorithm Configuration","text":"<p>The calibration process utilizes a genetic algorithm. The configuration file includes parameters that allow users to tune the genetic algorithm for optimal performance.</p> <p>Note</p> <p>To use the values from the default config file, simply do not include those lines in your custom config file.</p> <ul> <li>population_size: Defines the number of candidate solutions in each generation. A larger population increases diversity and enhances the search, but require more computational resources. Very small populations can reduce the genetic algorithm's ability to explore the solution space, potentially preventing it from finding the optimal solution.</li> <li>generations: Specifies the maximum number of iterations the algorithm can perform. Increasing this value allows more opportunities for improvement, but leads to longer runtimes. The calibration process will terminate early if a solution that meets the user's acceptance criteria is found before reaching this limit.</li> <li>mutation_probability: Determines the likelihood of random changes being introduced in offspring. Higher mutation rates encourage exploration of new solutions but may destabilize good candidates.</li> <li>crossover_probability: Specifies the probability that two parent solutions will combine to produce a child. Higher crossover rates encourage the exploitation of good solutions; however, excessive rates may reduce overall diversity.</li> </ul>"},{"location":"search_config/#optimizing-parameters-practical-guidance","title":"Optimizing Parameters: Practical Guidance","text":"<ul> <li>Testing with Small Values:\u00a0Employ reduced population sizes and fewer generations during initial testing phases to quickly validate code and workflow.</li> <li>Calibration with Larger Values:\u00a0For full-scale calibration, increase both population_size and generations to achieve a more comprehensive search. We recommend population sizes between 30\u2013100 and similar ranges for generations. Note that the effectiveness of larger population sizes or more generations depends on the number and granularity of available calibration adjustment knobs. If only a few knobs are being tuned, excessively large values may not provide meaningful improvements.</li> <li>Balance Exploration and Intensification:<ul> <li>if the search space is complex, consider increasing the crossover and mutation probabilities to ensure thorough exploration and solution coverage.</li> <li>Higher crossover and mutation probabilities (greater than 0.1 or 10%) can enhance the algorithm's ability to investigate new search spaces, while lower probabilities tend to concentrate the search on refining and intensifying existing solutions.</li> <li>Higher crossover and mutation probabilities may result in longer search time.</li> </ul> </li> <li>Evaluating Results:\u00a0Experiment with different parameter settings and compare outcomes to achieve an optimal balance between solution quality and computational efficiency.</li> <li>Tune Based on Constraints: When computational resources are limited, smaller populations, fewer generations, and smaller crossover and mutation probabilities may still yield useful results. It\u2019s often necessary to experiment with different values to find the optimal values for a particular problem.</li> </ul>"},{"location":"search_config/#value-choices","title":"Value Choices","text":"<p>These arrays contain the discrete options that the genetic algorithm will evaluate to calibrate the model. The values are multipliers (or temperature offsets) applied to elements in the HPXML model. For multipliers, 1 means no change, 0.1 means 1/10th of the original value, and 10 means 10x the original value. For temperature offsets, 0 means no change, -2 means a decrease of 2 deg-F, and 2 means an increase of 2 deg-F. Each home should have a custom config file for what is known about that home in particular. For instance, if a blower door test was completed on a home, you could use a very small range (to account for uncertainty in the infiltration algorithm) or no range for the air leakage choices in that home. We think a safe principle is to start with narrow ranges and few options the first time you attempt calibration of a home, and then subsequently expand the options/ranges if the calibration is not successful.</p> <ul> <li>Numbers farther away from 1 signify more uncertainty in the original model.<ul> <li>If those settings aren't able to generate a model that meets the acceptance criteria, try expanding the range.<ul> <li>Instead of <code>[0.5, 1, 2]</code>, consider <code>[0.25, 1, 4]</code></li> </ul> </li> </ul> </li> <li>More values inside the array give the genetic algorithm more granularity to find a solution.<ul> <li>If the quality of the output isn't very good, more granularity could help.<ul> <li>Instead of <code>[0.5, 1, 2]</code>, consider <code>[0.5, 0.75, 1, 1.5, 2]</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"search_config/#the-choices-in-the-config-file-adjust-the-following-hpxml-values","title":"The choices in the config file adjust the following hpxml values","text":"<p>If your model doesn't contain any of them, that field is ignored. For instance, if your model doesn't include a permanent spa, calibration will not fail because of that, nor will it create a spa. We hope it behaves the way a reasonable person would expect it to.</p>"},{"location":"search_config/#misc_load_multiplier_choices","title":"misc_load_multiplier_choices","text":"<ul> <li>plug load</li> <li>fuel load</li> <li>pool pump usage</li> <li>pool heater usage</li> <li>permanent spa pump usage</li> <li>permanent spa heater usage</li> </ul>"},{"location":"search_config/#air_leakage_multiplier_choices","title":"air_leakage_multiplier_choices","text":"<ul> <li>air leakage</li> <li>effective leakage area</li> </ul>"},{"location":"search_config/#heating_efficiency_multiplier_choices","title":"heating_efficiency_multiplier_choices","text":"<ul> <li>heating efficiency afue</li> <li>heating efficiency percent</li> <li>heat pump hspf</li> <li>heat pump hspf2</li> <li>heat pump cop</li> </ul>"},{"location":"search_config/#cooling_efficiency_multiplier_choices","title":"cooling_efficiency_multiplier_choices","text":"<ul> <li>cooling efficiency seer</li> <li>cooling efficiency seer2</li> <li>cooling efficiency eer</li> <li>cooling efficiency ceer</li> <li>heat pump cooling efficiency seer</li> <li>heat pump cooling efficiency seer2</li> <li>heat pump cooling efficiency eer</li> <li>heat pump cooling efficiency ceer</li> </ul>"},{"location":"search_config/#roof_r_value_multiplier_choices","title":"roof_r_value_multiplier_choices","text":"<ul> <li>insulation assembly r value</li> </ul>"},{"location":"search_config/#ceiling_r_value_multiplier_choices","title":"ceiling_r_value_multiplier_choices","text":"<ul> <li>attic floor insulation assembly r value</li> </ul>"},{"location":"search_config/#above_ground_walls_r_value_multiplier_choices","title":"above_ground_walls_r_value_multiplier_choices","text":"<ul> <li>above-ground walls and rim joists assembly r value</li> </ul>"},{"location":"search_config/#below_ground_walls_r_value_multiplier_choices","title":"below_ground_walls_r_value_multiplier_choices","text":"<ul> <li>exterior insulation r value</li> <li>interior insulation r value</li> <li>assembly insulation r value</li> </ul>"},{"location":"search_config/#slab_r_value_multiplier_choices","title":"slab_r_value_multiplier_choices","text":"<ul> <li>under-slab insulation r value</li> <li>slab perimeter insulation r value</li> <li>slab exterior horizontal insulation r value</li> <li>slab gap insulation r value</li> </ul>"},{"location":"search_config/#floor_r_value_multiplier_choices","title":"floor_r_value_multiplier_choices","text":"<ul> <li>floor insulation assembly r value</li> </ul>"},{"location":"search_config/#heating_setpoint_offset_choices","title":"heating_setpoint_offset_choices","text":"<ul> <li>heating setpoint</li> <li>heating setback</li> <li>wekday heating setpoints</li> </ul>"},{"location":"search_config/#cooling_setpoint_offset_choices","title":"cooling_setpoint_offset_choices","text":"<ul> <li>cooling setpoint</li> <li>cooling setback</li> <li>wekday cooling setpoints</li> </ul>"},{"location":"search_config/#water_heater_efficiency_multiplier_choices","title":"water_heater_efficiency_multiplier_choices","text":"<ul> <li>water heater energy factor</li> <li>water heater uniform energy factor</li> </ul>"},{"location":"search_config/#water_fixtures_usage_multiplier_choices","title":"water_fixtures_usage_multiplier_choices","text":"<ul> <li>water fixtures usage</li> </ul>"},{"location":"search_config/#window_u_factor_multiplier_choices","title":"window_u_factor_multiplier_choices","text":"<ul> <li>window u factor</li> </ul>"},{"location":"search_config/#window_shgc_multiplier_choices","title":"window_shgc_multiplier_choices","text":"<ul> <li>window shgc</li> </ul>"},{"location":"search_config/#appliance_usage_multiplier_choices","title":"appliance_usage_multiplier_choices","text":"<ul> <li>appliance usage<ul> <li>refrigerators</li> <li>clothes washers</li> <li>clothes dryers</li> <li>dishwashers</li> <li>freezers</li> <li>cooking ranges</li> </ul> </li> </ul>"},{"location":"search_config/#lighting_load_multiplier_choices","title":"lighting_load_multiplier_choices","text":"<ul> <li>interior lighting usage</li> </ul>"},{"location":"code_documentation/calibrate/","title":"Calibrate","text":""},{"location":"code_documentation/calibrate/#src.openstudio_hpxml_calibration.calibrate.Calibrate","title":"<code>Calibrate</code>","text":"Source code in <code>src/openstudio_hpxml_calibration/calibrate.py</code> <pre><code>class Calibrate:\n    def __init__(\n        self,\n        original_hpxml_filepath: Path,\n        csv_bills_filepath: Path | None = None,\n        config_filepath: Path | None = None,\n    ):\n        \"\"\"Initialize the Calibrate class.\n\n        :param original_hpxml_filepath: Path to the original HPXML file.\n        :type original_hpxml_filepath: Path\n        :param csv_bills_filepath: Optional path to the utility bills CSV file.\n        :type csv_bills_filepath: Path | None, optional\n        :param config_filepath: Optional path to the configuration file.\n        :type config_filepath: Path | None, optional\n        \"\"\"\n        self.hpxml_filepath = Path(original_hpxml_filepath).resolve()\n        self.hpxml = HpxmlDoc(Path(original_hpxml_filepath).resolve())\n        self.ga_config = _load_config(config_filepath)\n\n        if csv_bills_filepath:\n            logger.debug(f\"Adding utility data from {csv_bills_filepath} to hpxml\")\n            self.hpxml = set_consumption_on_hpxml(self.hpxml, csv_bills_filepath)\n\n        self.hpxml.hpxml_data_error_checking(self.ga_config)\n\n    def get_normalized_consumption_per_bill(self) -&gt; dict[FuelType, pd.DataFrame]:\n        \"\"\"Get the normalized consumption for the building.\n\n        :return: Dictionary containing dataframes for the normalized consumption by end use and fuel type, in MBtu.\n        :rtype: dict[FuelType, pd.DataFrame]\n        \"\"\"\n\n        normalized_consumption = {}\n        # InverseModel is not applicable to delivered fuels, so we only use it for electricity and natural gas\n        self.inv_model = InverseModel(self.hpxml, user_config=self.ga_config)\n        for fuel_type, bills in self.inv_model.bills_by_fuel_type.items():\n            if fuel_type in (\n                FuelType.FUEL_OIL,\n                FuelType.PROPANE,\n                FuelType.WOOD,\n                FuelType.WOOD_PELLETS,\n            ):\n                continue  # Delivered fuels have a separate calibration process: simplified_annual_usage()\n\n            def _calculate_wrapped_total(row):\n                \"\"\"Extract the epw_daily rows that correspond to the bill month\n\n                Search by row index because epw_daily is just 365 entries without dates\n                \"\"\"\n                start = row[\"start_day_of_year\"]\n                end = row[\"end_day_of_year\"]\n\n                if start &lt;= end:\n                    subset = epw_daily_mbtu.iloc[start:end].sum()\n                else:\n                    # handle bills that wrap around the end of the year\n                    part1 = epw_daily_mbtu.iloc[start:].sum()\n                    part2 = epw_daily_mbtu.iloc[0:end].sum()\n                    subset = pd.concat(objs=[part1, part2])\n                    subset = subset[~subset.index.duplicated()]\n\n                return subset\n\n            try:\n                predicted_daily_btu = self.inv_model.predict_epw_daily(fuel_type=fuel_type)\n                epw_daily_kbtu = convert_units(x=predicted_daily_btu, from_=\"btu\", to_=\"kbtu\")\n\n                epw_daily_mbtu = convert_units(epw_daily_kbtu, from_=\"kbtu\", to_=\"mbtu\")\n\n                normalized_consumption[fuel_type.value] = pd.DataFrame(\n                    data=bills.apply(_calculate_wrapped_total, axis=1)\n                )\n                normalized_consumption[fuel_type.value][\"start_date\"] = bills[\"start_date\"]\n                normalized_consumption[fuel_type.value][\"end_date\"] = bills[\"end_date\"]\n            except Bpi2400ModelFitError:\n                continue\n\n        return normalized_consumption\n\n    def get_model_results(self, json_results_path: Path) -&gt; dict[str, dict[str, float]]:\n        \"\"\"Retrieve annual energy usage from the HPXML model.\n\n        :param json_results_path: Path to the JSON file containing annual results from the HPXML model.\n        :type json_results_path: Path\n        :return: Model results for each fuel type by end use in MBtu.\n        :rtype: dict[str, dict[str, float]]\n        \"\"\"\n\n        results = json.loads(json_results_path.read_text())\n        if \"Time\" in results:\n            raise ValueError(f\"your file {json_results_path} is not an annual results file\")\n\n        model_output = {\n            \"electricity\": {},\n            \"natural gas\": {},\n            \"propane\": {},\n            \"fuel oil\": {},\n            \"wood cord\": {},\n            \"wood pellets\": {},\n            \"coal\": {},\n        }\n\n        for end_use, consumption in results[\"End Use\"].items():\n            fuel_type = end_use.split(\":\")[0].lower().strip()\n            # ignore electricity usage for heating (fans/pumps) when electricity is not the fuel type for any heating system\n            if (\n                fuel_type == \"electricity\"\n                and \"Heating\" in end_use\n                and FuelType.ELECTRICITY.value not in self.hpxml.get_fuel_types()[\"heating\"]\n            ):\n                continue\n            if \"Heating\" in end_use:\n                model_output[fuel_type][\"heating\"] = round(\n                    number=(model_output[fuel_type].get(\"heating\", 0) + consumption), ndigits=3\n                )\n            elif \"Cooling\" in end_use:\n                model_output[fuel_type][\"cooling\"] = round(\n                    number=(model_output[fuel_type].get(\"cooling\", 0) + consumption), ndigits=3\n                )\n            else:\n                model_output[fuel_type][\"baseload\"] = round(\n                    number=(model_output[fuel_type].get(\"baseload\", 0) + consumption), ndigits=3\n                )\n\n        return model_output\n\n    def compare_results(\n        self, normalized_consumption: dict[str, pd.DataFrame], annual_model_results\n    ) -&gt; dict[str, dict[str, dict[str, float]]]:\n        \"\"\"Compare the normalized consumption with the model results.\n\n        :param normalized_consumption: Normalized consumption data (MBtu).\n        :type normalized_consumption: dict[str, pd.DataFrame]\n        :param annual_model_results: Model results data (MBtu).\n        :type annual_model_results: dict\n        :return: Comparison results containing bias and absolute errors for each fuel type and end use.\n        :rtype: dict[str, dict[str, dict[str, float]]]\n        \"\"\"\n\n        # Build annual normalized bill consumption dicts\n        annual_normalized_bill_consumption = {}\n        for fuel_type, consumption in normalized_consumption.items():\n            annual_normalized_bill_consumption[fuel_type] = {}\n            for end_use in [\"heating\", \"cooling\", \"baseload\"]:\n                if (\n                    end_use not in annual_model_results[fuel_type]\n                    or annual_model_results[fuel_type][end_use] == 0.0\n                ):\n                    continue\n                annual_normalized_bill_consumption[fuel_type][end_use] = (\n                    consumption[end_use].sum().round(1)\n                )\n\n        comparison_results = {}\n\n        # combine the annual normalized bill consumption with the model results\n        for model_fuel_type, disagg_results in annual_model_results.items():\n            if model_fuel_type in annual_normalized_bill_consumption:\n                comparison_results[model_fuel_type] = {\"Bias Error\": {}, \"Absolute Error\": {}}\n                for load_type in disagg_results:\n                    if load_type not in annual_normalized_bill_consumption[model_fuel_type]:\n                        continue\n\n                    disagg_result = disagg_results[load_type]\n                    if model_fuel_type == \"electricity\":\n                        # All results from simulation and normalized bills are in MBtu.\n                        # convert electric loads from MBtu to kWh for bpi2400\n                        annual_normalized_bill_consumption[model_fuel_type][load_type] = (\n                            convert_units(\n                                annual_normalized_bill_consumption[model_fuel_type][load_type],\n                                from_=\"mbtu\",\n                                to_=\"kwh\",\n                            )\n                        )\n                        disagg_result = convert_units(disagg_result, from_=\"mbtu\", to_=\"kwh\")\n\n                    # Calculate error levels\n                    if annual_normalized_bill_consumption[model_fuel_type][load_type] == 0:\n                        comparison_results[model_fuel_type][\"Bias Error\"][load_type] = float(\"nan\")\n                    else:\n                        comparison_results[model_fuel_type][\"Bias Error\"][load_type] = round(\n                            (\n                                (\n                                    annual_normalized_bill_consumption[model_fuel_type][load_type]\n                                    - disagg_result\n                                )\n                                / annual_normalized_bill_consumption[model_fuel_type][load_type]\n                            )\n                            * 100,\n                            1,\n                        )\n                    comparison_results[model_fuel_type][\"Absolute Error\"][load_type] = round(\n                        abs(\n                            annual_normalized_bill_consumption[model_fuel_type][load_type]\n                            - disagg_result\n                        ),\n                        1,\n                    )\n\n        return comparison_results\n\n    def simplified_annual_usage(\n        self, model_results: dict, delivered_consumption, fuel_type: str\n    ) -&gt; dict:\n        \"\"\"Perform simplified annual usage calibration for delivered fuels.\n\n        Estimates annual fuel usage and compares measured consumption with modeled results\n        for fuels that cannot be weather-normalized (e.g., fuel oil, propane, wood).\n        Calculates bias and absolute errors for baseload, heating, and cooling end uses.\n\n        :param model_results: Annual model results by fuel type and end use.\n        :type model_results: dict\n        :param delivered_consumption: Consumption data object for the delivered fuel.\n        :type delivered_consumption: object\n        :param fuel_type: The fuel type being calibrated.\n        :type fuel_type: str\n        :return: Tuple containing bias and absolute error metrics for each end use, and weather-normalized annual consumption by end use.\n        :rtype: tuple[dict, dict]\n        \"\"\"\n        total_period_tmy_dd, total_period_actual_dd = calculate_annual_degree_days(self.hpxml)\n\n        comparison_results = {}\n        if isinstance(model_results, str):\n            model_results = json.loads(model_results)\n\n        measured_consumption = 0.0\n        fuel_unit_type = delivered_consumption.ConsumptionType.Energy.UnitofMeasure\n        if delivered_consumption.ConsumptionType.Energy.FuelType == fuel_type:\n            first_bill_date = delivered_consumption.ConsumptionDetail[0].StartDateTime\n            last_bill_date = delivered_consumption.ConsumptionDetail[-1].EndDateTime\n            first_bill_date = dt.strptime(str(first_bill_date), \"%Y-%m-%dT%H:%M:%S\")\n            last_bill_date = dt.strptime(str(last_bill_date), \"%Y-%m-%dT%H:%M:%S\")\n            num_days = (last_bill_date - first_bill_date + timedelta(days=1)).days\n            for period_consumption in delivered_consumption.ConsumptionDetail:\n                measured_consumption += float(period_consumption.Consumption)\n            # logger.debug(\n            #     f\"Measured {fuel_type} consumption: {measured_consumption:,.2f} {fuel_unit_type}\"\n            # )\n            if fuel_unit_type == \"gal\" and fuel_type == FuelType.FUEL_OIL.value:\n                fuel_unit_type = f\"{fuel_unit_type}_fuel_oil\"\n            elif fuel_unit_type == \"gal\" and fuel_type == FuelType.PROPANE.value:\n                fuel_unit_type = f\"{fuel_unit_type}_propane\"\n            elif fuel_unit_type == \"therms\":\n                fuel_unit_type = \"therm\"\n        measured_consumption = convert_units(measured_consumption, str(fuel_unit_type), \"mBtu\")\n\n        modeled_baseload = model_results[fuel_type].get(\"baseload\", 0)\n        modeled_heating = model_results[fuel_type].get(\"heating\", 0)\n        modeled_cooling = model_results[fuel_type].get(\"cooling\", 0)\n        total_modeled_usage = modeled_baseload + modeled_heating + modeled_cooling\n\n        baseload_fraction = modeled_baseload / total_modeled_usage\n        heating_fraction = modeled_heating / total_modeled_usage\n        cooling_fraction = modeled_cooling / total_modeled_usage\n\n        baseload = baseload_fraction * (num_days / 365)\n        heating = heating_fraction * (\n            total_period_actual_dd[fuel_type][\"HDD65F\"] / total_period_tmy_dd[fuel_type][\"HDD65F\"]\n        )\n        cooling = cooling_fraction * (\n            total_period_actual_dd[fuel_type][\"CDD65F\"] / total_period_tmy_dd[fuel_type][\"CDD65F\"]\n        )\n\n        annual_delivered_fuel_usage = measured_consumption / (baseload + heating + cooling)\n        # logger.debug(f\"annual_delivered_fuel_usage: {annual_delivered_fuel_usage:,.2f} mBtu\")\n\n        normalized_annual_baseload = annual_delivered_fuel_usage * baseload_fraction\n        normalized_annual_heating = annual_delivered_fuel_usage * heating_fraction\n        normalized_annual_cooling = annual_delivered_fuel_usage * cooling_fraction\n\n        baseload_bias_error = (\n            ((normalized_annual_baseload - modeled_baseload) / normalized_annual_baseload) * 100\n            if normalized_annual_baseload\n            else 0\n        )\n        heating_bias_error = (\n            ((normalized_annual_heating - modeled_heating) / normalized_annual_heating) * 100\n            if normalized_annual_heating\n            else 0\n        )\n        cooling_bias_error = (\n            ((normalized_annual_cooling - modeled_cooling) / normalized_annual_cooling) * 100\n            if normalized_annual_cooling\n            else 0\n        )\n\n        baseload_absolute_error = abs(normalized_annual_baseload - modeled_baseload)\n        heating_absolute_error = abs(normalized_annual_heating - modeled_heating)\n        cooling_absolute_error = abs(normalized_annual_cooling - modeled_cooling)\n\n        comparison_results[fuel_type] = {\n            \"Bias Error\": {\n                \"baseload\": round(baseload_bias_error, 2),\n                \"heating\": round(heating_bias_error, 2),\n                \"cooling\": round(cooling_bias_error, 2),\n            },\n            \"Absolute Error\": {\n                \"baseload\": round(baseload_absolute_error, 2),\n                \"heating\": round(heating_absolute_error, 2),\n                \"cooling\": round(cooling_absolute_error, 2),\n            },\n        }\n        normalized_annual_end_uses = {\n            \"baseload\": round(normalized_annual_baseload, 2),\n            \"heating\": round(normalized_annual_heating, 2),\n            \"cooling\": round(normalized_annual_cooling, 2),\n        }\n        return comparison_results, normalized_annual_end_uses\n\n    def _process_calibration_results(\n        self, simulation_results, normalized_consumption_per_bill, for_summary=False\n    ):\n        \"\"\"Process calibration results based on simulation data and consumption data.\n\n        Handles both the evaluation of a single individual and the construction of the regression model summary.\n\n        :param simulation_results: Simulation results from the HPXML model.\n        :type simulation_results: dict\n        :param normalized_consumption_per_bill: Weather-normalized consumption data.\n        :type normalized_consumption_per_bill: dict\n        :param for_summary: If True, returns summary information for documentation.\n        :type for_summary: bool, optional\n        :return: Tuple containing comparison error metrics and regression model summary details.\n        :rtype: tuple\n        \"\"\"\n        comparison = {}\n        summary = {}\n        delivered_fuels = (\n            FuelType.FUEL_OIL.value,\n            FuelType.PROPANE.value,\n            FuelType.WOOD.value,\n            FuelType.WOOD_PELLETS.value,\n        )\n        consumptions = self.hpxml.get_consumptions()\n\n        for consumption in consumptions:\n            for fuel_info in consumption.ConsumptionDetails.ConsumptionInfo:\n                fuel = fuel_info.ConsumptionType.Energy.FuelType.text\n\n                if fuel in delivered_fuels:\n                    simplified_results, normalized_annual_end_uses = self.simplified_annual_usage(\n                        simulation_results, fuel_info, fuel\n                    )\n                    comparison[fuel] = simplified_results.get(fuel, {})\n                    if for_summary:\n                        summary[fuel] = {\n                            \"calibration_type\": \"simplified\",\n                            \"consumption\": normalized_annual_end_uses,\n                        }\n                else:\n                    try:\n                        # detailed calibration logic\n                        if for_summary:\n                            for (\n                                reg_model_fuel,\n                                reg_model,\n                            ) in self.inv_model.regression_models.items():\n                                if fuel == reg_model_fuel.value:\n                                    end_use_sums = (\n                                        normalized_consumption_per_bill[fuel]\n                                        .get([\"baseload\", \"heating\", \"cooling\"], 0)\n                                        .sum()\n                                        .to_dict()\n                                    )\n                                    summary[fuel] = {\n                                        \"calibration_type\": \"detailed\",\n                                        \"model_type\": getattr(reg_model, \"MODEL_NAME\", None),\n                                        \"cvrmse\": getattr(reg_model, \"cvrmse\", None),\n                                        \"consumption\": end_use_sums,\n                                    }\n                        else:\n                            comparison.update(\n                                self.compare_results(\n                                    normalized_consumption_per_bill, simulation_results\n                                )\n                            )\n\n                    except Bpi2400ModelFitError:\n                        logger.info(\n                            \"Could not normalize consumption to weather with sufficient accuracy. Switching to simplified calibration technique.\"\n                        )\n                        simplified_results, normalized_annual_end_uses = (\n                            self.simplified_annual_usage(simulation_results, fuel_info, fuel)\n                        )\n                        comparison[fuel] = simplified_results.get(fuel, {})\n                        if for_summary:\n                            summary[fuel] = {\n                                \"calibration_type\": \"simplified\",\n                                \"consumption\": normalized_annual_end_uses,\n                            }\n\n        return comparison, summary\n\n    def create_measure_input_file(\n        self, arguments: dict, output_file_path: str, measure_path: str | None = None\n    ):\n        if measure_path is None:\n            measure_path = str(Path(__file__).resolve().parent.parent / \"measures\")\n        data = {\n            \"run_directory\": str(Path(arguments[\"save_file_path\"]).parent),\n            \"measure_paths\": [measure_path],\n            \"steps\": [{\"measure_dir_name\": \"ModifyXML\", \"arguments\": arguments}],\n        }\n        Path(output_file_path).parent.mkdir(parents=True, exist_ok=True)\n        with open(output_file_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(data, f, indent=2)\n\n    def run_search(\n        self,\n        population_size=None,\n        generations=None,\n        cxpb=None,\n        mutpb=None,\n        num_proc=None,\n        output_filepath=None,\n        save_all_results=False,\n    ):\n        \"\"\"Run the genetic algorithm search for calibration.\n\n        :param population_size: Number of individuals in the population.\n        :type population_size: int, optional\n        :param generations: Number of generations to run.\n        :type generations: int, optional\n        :param cxpb: Crossover probability.\n        :type cxpb: float, optional\n        :param mutpb: Mutation probability.\n        :type mutpb: float, optional\n        :param num_proc: Number of parallel processes to use.\n        :type num_proc: int, optional\n        :param output_filepath: Directory to save output files.\n        :type output_filepath: Path, optional\n        :param save_all_results: If True, saves all simulation results.\n        :type save_all_results: bool, optional\n        :return: Tuple containing best individual, population, logbook, error series, regression models, and results.\n        :rtype: tuple\n        \"\"\"\n        print(f\"Running search algorithm for '{Path(self.hpxml_filepath).name}'...\")\n\n        all_temp_dirs = set()\n        best_dirs_by_gen = []\n        cfg = self.ga_config\n        population_size = cfg[\"genetic_algorithm\"][\"population_size\"]\n        generations = cfg[\"genetic_algorithm\"][\"generations\"]\n        bias_error_threshold = cfg[\"acceptance_criteria\"][\"bias_error_threshold\"]\n        abs_error_elec_threshold = cfg[\"acceptance_criteria\"][\"abs_error_elec_threshold\"]\n        abs_error_fuel_threshold = cfg[\"acceptance_criteria\"][\"abs_error_fuel_threshold\"]\n        cxpb = cfg[\"genetic_algorithm\"][\"crossover_probability\"]\n        mutpb = cfg[\"genetic_algorithm\"][\"mutation_probability\"]\n        misc_load_multiplier_choices = cfg[\"value_choices\"][\"misc_load_multiplier_choices\"]\n        air_leakage_multiplier_choices = cfg[\"value_choices\"][\"air_leakage_multiplier_choices\"]\n        heating_efficiency_multiplier_choices = cfg[\"value_choices\"][\n            \"heating_efficiency_multiplier_choices\"\n        ]\n        cooling_efficiency_multiplier_choices = cfg[\"value_choices\"][\n            \"cooling_efficiency_multiplier_choices\"\n        ]\n        roof_r_value_multiplier_choices = cfg[\"value_choices\"][\"roof_r_value_multiplier_choices\"]\n        ceiling_r_value_multiplier_choices = cfg[\"value_choices\"][\n            \"ceiling_r_value_multiplier_choices\"\n        ]\n        above_ground_walls_r_value_multiplier_choices = cfg[\"value_choices\"][\n            \"above_ground_walls_r_value_multiplier_choices\"\n        ]\n        below_ground_walls_r_value_multiplier_choices = cfg[\"value_choices\"][\n            \"below_ground_walls_r_value_multiplier_choices\"\n        ]\n        slab_r_value_multiplier_choices = cfg[\"value_choices\"][\"slab_r_value_multiplier_choices\"]\n        floor_r_value_multiplier_choices = cfg[\"value_choices\"][\"floor_r_value_multiplier_choices\"]\n        heating_setpoint_offset_choices = cfg[\"value_choices\"][\"heating_setpoint_offset_choices\"]\n        cooling_setpoint_offset_choices = cfg[\"value_choices\"][\"cooling_setpoint_offset_choices\"]\n        water_heater_efficiency_multiplier_choices = cfg[\"value_choices\"][\n            \"water_heater_efficiency_multiplier_choices\"\n        ]\n        water_fixtures_usage_multiplier_choices = cfg[\"value_choices\"][\n            \"water_fixtures_usage_multiplier_choices\"\n        ]\n        window_u_factor_multiplier_choices = cfg[\"value_choices\"][\n            \"window_u_factor_multiplier_choices\"\n        ]\n        window_shgc_multiplier_choices = cfg[\"value_choices\"][\"window_shgc_multiplier_choices\"]\n        appliance_usage_multiplier_choices = cfg[\"value_choices\"][\n            \"appliance_usage_multiplier_choices\"\n        ]\n        lighting_load_multiplier_choices = cfg[\"value_choices\"][\"lighting_load_multiplier_choices\"]\n\n        normalized_consumption_per_bill = self.get_normalized_consumption_per_bill()\n\n        def evaluate(individual):\n            try:\n                (\n                    misc_load_multiplier,\n                    heating_setpoint_offset,\n                    cooling_setpoint_offset,\n                    air_leakage_multiplier,\n                    heating_efficiency_multiplier,\n                    cooling_efficiency_multiplier,\n                    roof_r_value_multiplier,\n                    ceiling_r_value_multiplier,\n                    above_ground_walls_r_value_multiplier,\n                    below_ground_walls_r_value_multiplier,\n                    slab_r_value_multiplier,\n                    floor_r_value_multiplier,\n                    water_heater_efficiency_multiplier,\n                    water_fixtures_usage_multiplier,\n                    window_u_factor_multiplier,\n                    window_shgc_multiplier,\n                    appliance_usage_multiplier,\n                    lighting_load_multiplier,\n                ) = individual\n                temp_output_dir = Path(\n                    tempfile.mkdtemp(prefix=f\"calib_test_{uuid.uuid4().hex[:6]}_\")\n                )\n                mod_hpxml_path = temp_output_dir / \"modified.xml\"\n                arguments = {\n                    \"xml_file_path\": str(self.hpxml_filepath),\n                    \"save_file_path\": str(mod_hpxml_path),\n                    \"misc_load_multiplier\": misc_load_multiplier,\n                    \"heating_setpoint_offset\": heating_setpoint_offset,\n                    \"cooling_setpoint_offset\": cooling_setpoint_offset,\n                    \"air_leakage_multiplier\": air_leakage_multiplier,\n                    \"heating_efficiency_multiplier\": heating_efficiency_multiplier,\n                    \"cooling_efficiency_multiplier\": cooling_efficiency_multiplier,\n                    \"roof_r_value_multiplier\": roof_r_value_multiplier,\n                    \"ceiling_r_value_multiplier\": ceiling_r_value_multiplier,\n                    \"above_ground_walls_r_value_multiplier\": above_ground_walls_r_value_multiplier,\n                    \"below_ground_walls_r_value_multiplier\": below_ground_walls_r_value_multiplier,\n                    \"slab_r_value_multiplier\": slab_r_value_multiplier,\n                    \"floor_r_value_multiplier\": floor_r_value_multiplier,\n                    \"water_heater_efficiency_multiplier\": water_heater_efficiency_multiplier,\n                    \"water_fixtures_usage_multiplier\": water_fixtures_usage_multiplier,\n                    \"window_u_factor_multiplier\": window_u_factor_multiplier,\n                    \"window_shgc_multiplier\": window_shgc_multiplier,\n                    \"appliance_usage_multiplier\": appliance_usage_multiplier,\n                    \"lighting_load_multiplier\": lighting_load_multiplier,\n                }\n\n                temp_osw = Path(temp_output_dir / \"modify_hpxml.osw\")\n                self.create_measure_input_file(arguments, temp_osw)\n\n                app([\"modify-xml\", str(temp_osw)])\n                app(\n                    [\n                        \"run-sim\",\n                        str(mod_hpxml_path),\n                        \"--output-dir\",\n                        str(temp_output_dir),\n                        \"--output-format\",\n                        \"json\",\n                    ]\n                )\n\n                output_file = temp_output_dir / \"run\" / \"results_annual.json\"\n                simulation_results = self.get_model_results(json_results_path=output_file)\n                comparison, _ = self._process_calibration_results(\n                    simulation_results, normalized_consumption_per_bill\n                )\n\n                for model_fuel_type, result in comparison.items():\n                    bias_error_criteria = self.ga_config[\"acceptance_criteria\"][\n                        \"bias_error_threshold\"\n                    ]\n                    if model_fuel_type == \"electricity\":\n                        absolute_error_criteria = self.ga_config[\"acceptance_criteria\"][\n                            \"abs_error_elec_threshold\"\n                        ]\n                    else:\n                        absolute_error_criteria = self.ga_config[\"acceptance_criteria\"][\n                            \"abs_error_fuel_threshold\"\n                        ]\n                    for load_type in result[\"Bias Error\"]:\n                        if abs(result[\"Bias Error\"][load_type]) &gt; bias_error_criteria:\n                            logger.debug(\n                                f\"Bias error for {model_fuel_type} {load_type} is {result['Bias Error'][load_type]} but the limit is +/- {bias_error_criteria}\"\n                            )\n                        if abs(result[\"Absolute Error\"][load_type]) &gt; absolute_error_criteria:\n                            logger.debug(\n                                f\"Absolute error for {model_fuel_type} {load_type} is {result['Absolute Error'][load_type]} but the limit is +/- {absolute_error_criteria}\"\n                            )\n\n                combined_error_penalties = []\n                for fuel_type, metrics in comparison.items():\n                    for end_use, bias_error in metrics[\"Bias Error\"].items():\n                        if math.isnan(bias_error) or math.isnan(metrics[\"Absolute Error\"][end_use]):\n                            continue  # Skip NaN values\n\n                        bias_err = abs(bias_error)\n                        abs_err = abs(metrics[\"Absolute Error\"][end_use])\n\n                        log_bias_err = math.log1p(bias_err)  # log1p to avoid log(0)\n                        log_abs_err = math.log1p(abs_err)\n\n                        bias_error_penalty = max(0, log_bias_err) ** 2\n                        abs_error_penalty = max(0, log_abs_err) ** 2\n                        combined_error_penalty = bias_error_penalty + abs_error_penalty\n\n                        combined_error_penalties.append(combined_error_penalty)\n\n                total_score = sum(combined_error_penalties)\n\n                return (\n                    (total_score,),\n                    comparison,\n                    temp_output_dir,\n                    simulation_results,\n                )\n\n            except Exception as e:\n                logger.error(f\"Error evaluating individual {individual}: {e}\")\n                return (float(\"inf\"),), {}, None\n\n        def abs_error_within_threshold(\n            fuel_type: str, abs_error: float, elec_threshold: float, fuel_threshold: float\n        ) -&gt; bool:\n            if fuel_type == \"electricity\":\n                return abs(abs_error) &lt;= elec_threshold\n            else:\n                return abs(abs_error) &lt;= fuel_threshold\n\n        def diversity(pop):\n            return len({tuple(ind) for ind in pop}) / len(pop)\n\n        def calc_stats(values):\n            if not values:\n                return {\"min\": None, \"max\": None, \"median\": None, \"std\": None}\n            return {\n                \"min\": min(values),\n                \"max\": max(values),\n                \"median\": statistics.median(values),\n                \"std\": statistics.pstdev(values) if len(values) &gt; 1 else 0.0,\n            }\n\n        def meets_termination_criteria(comparison):\n            all_bias_err_limit_met = True\n            all_abs_err_limit_met = True\n            for fuel_type, metrics in comparison.items():\n                for end_use in metrics[\"Bias Error\"]:\n                    bias_err = metrics[\"Bias Error\"][end_use]\n                    abs_err = metrics[\"Absolute Error\"][end_use]\n\n                    # Check bias error\n                    if abs(bias_err) &gt; bias_error_threshold:\n                        all_bias_err_limit_met = False\n\n                    # Check absolute error\n                    if not abs_error_within_threshold(\n                        fuel_type,\n                        abs_err,\n                        abs_error_elec_threshold,\n                        abs_error_fuel_threshold,\n                    ):\n                        all_abs_err_limit_met = False\n\n            return all_bias_err_limit_met or all_abs_err_limit_met\n\n        toolbox = base.Toolbox()\n        toolbox.register(\"attr_misc_load_multiplier\", random.choice, misc_load_multiplier_choices)\n        toolbox.register(\n            \"attr_heating_setpoint_offset\", random.choice, heating_setpoint_offset_choices\n        )\n        toolbox.register(\n            \"attr_cooling_setpoint_offset\", random.choice, cooling_setpoint_offset_choices\n        )\n        toolbox.register(\n            \"attr_air_leakage_multiplier\", random.choice, air_leakage_multiplier_choices\n        )\n        toolbox.register(\n            \"attr_heating_efficiency_multiplier\",\n            random.choice,\n            heating_efficiency_multiplier_choices,\n        )\n        toolbox.register(\n            \"attr_cooling_efficiency_multiplier\",\n            random.choice,\n            cooling_efficiency_multiplier_choices,\n        )\n        toolbox.register(\n            \"attr_roof_r_value_multiplier\", random.choice, roof_r_value_multiplier_choices\n        )\n        toolbox.register(\n            \"attr_ceiling_r_value_multiplier\", random.choice, ceiling_r_value_multiplier_choices\n        )\n        toolbox.register(\n            \"attr_above_ground_walls_r_value_multiplier\",\n            random.choice,\n            above_ground_walls_r_value_multiplier_choices,\n        )\n        toolbox.register(\n            \"attr_below_ground_walls_r_value_multiplier\",\n            random.choice,\n            below_ground_walls_r_value_multiplier_choices,\n        )\n        toolbox.register(\n            \"attr_slab_r_value_multiplier\", random.choice, slab_r_value_multiplier_choices\n        )\n        toolbox.register(\n            \"attr_floor_r_value_multiplier\", random.choice, floor_r_value_multiplier_choices\n        )\n        toolbox.register(\n            \"attr_water_heater_efficiency_multiplier\",\n            random.choice,\n            water_heater_efficiency_multiplier_choices,\n        )\n        toolbox.register(\n            \"attr_water_fixtures_usage_multiplier\",\n            random.choice,\n            water_fixtures_usage_multiplier_choices,\n        )\n        toolbox.register(\n            \"attr_window_u_factor_multiplier\", random.choice, window_u_factor_multiplier_choices\n        )\n        toolbox.register(\n            \"attr_window_shgc_multiplier\", random.choice, window_shgc_multiplier_choices\n        )\n        toolbox.register(\n            \"attr_appliance_usage_multiplier\", random.choice, appliance_usage_multiplier_choices\n        )\n        toolbox.register(\n            \"attr_lighting_load_multiplier\", random.choice, lighting_load_multiplier_choices\n        )\n        toolbox.register(\n            \"individual\",\n            tools.initRepeat,\n            creator.Individual,\n            (\n                toolbox.attr_misc_load_multiplier,\n                toolbox.attr_heating_setpoint_offset,\n                toolbox.attr_cooling_setpoint_offset,\n                toolbox.attr_air_leakage_multiplier,\n                toolbox.attr_heating_efficiency_multiplier,\n                toolbox.attr_cooling_efficiency_multiplier,\n                toolbox.attr_roof_r_value_multiplier,\n                toolbox.attr_ceiling_r_value_multiplier,\n                toolbox.attr_above_ground_walls_r_value_multiplier,\n                toolbox.attr_below_ground_walls_r_value_multiplier,\n                toolbox.attr_slab_r_value_multiplier,\n                toolbox.attr_floor_r_value_multiplier,\n                toolbox.attr_water_heater_efficiency_multiplier,\n                toolbox.attr_water_fixtures_usage_multiplier,\n                toolbox.attr_window_u_factor_multiplier,\n                toolbox.attr_window_shgc_multiplier,\n                toolbox.attr_appliance_usage_multiplier,\n                toolbox.attr_lighting_load_multiplier,\n            ),\n            n=18,\n        )\n\n        def create_seed_individual():\n            return creator.Individual(\n                [\n                    1,  # misc_load_multiplier\n                    0,  # heating_setpoint_offset\n                    0,  # cooling_setpoint_offset\n                    1,  # air_leakage_multiplier\n                    1,  # heating_efficiency_multiplier\n                    1,  # cooling_efficiency_multiplier\n                    1,  # roof_r_value_multiplier\n                    1,  # ceiling_r_value_multiplier\n                    1,  # above_ground_walls_r_value_multiplier\n                    1,  # below_ground_walls_r_value_multiplier\n                    1,  # slab_r_value_multiplier\n                    1,  # floor_r_value_multiplier\n                    1,  # water_heater_efficiency_multiplier\n                    1,  # water_fixtures_usage_multiplier\n                    1,  # window_u_factor_multiplier\n                    1,  # window_shgc_multiplier\n                    1,  # appliance_usage_multiplier\n                    1,  # lighting_load_multiplier\n                ]\n            )\n\n        def generate_random_individual():\n            return creator.Individual(\n                [\n                    random.choice(misc_load_multiplier_choices),\n                    random.choice(heating_setpoint_offset_choices),\n                    random.choice(cooling_setpoint_offset_choices),\n                    random.choice(air_leakage_multiplier_choices),\n                    random.choice(heating_efficiency_multiplier_choices),\n                    random.choice(cooling_efficiency_multiplier_choices),\n                    random.choice(roof_r_value_multiplier_choices),\n                    random.choice(ceiling_r_value_multiplier_choices),\n                    random.choice(above_ground_walls_r_value_multiplier_choices),\n                    random.choice(below_ground_walls_r_value_multiplier_choices),\n                    random.choice(slab_r_value_multiplier_choices),\n                    random.choice(floor_r_value_multiplier_choices),\n                    random.choice(water_heater_efficiency_multiplier_choices),\n                    random.choice(water_fixtures_usage_multiplier_choices),\n                    random.choice(window_u_factor_multiplier_choices),\n                    random.choice(window_shgc_multiplier_choices),\n                    random.choice(appliance_usage_multiplier_choices),\n                    random.choice(lighting_load_multiplier_choices),\n                ]\n            )\n\n        def is_existing_home(individual, param_choices_map):\n            return all(\n                val == 1\n                for key, val in zip(param_choices_map.keys(), individual)\n                if \"multiplier\" in key\n            ) and all(\n                val == 0\n                for key, val in zip(param_choices_map.keys(), individual)\n                if \"offset\" in key\n            )\n\n        toolbox.register(\"individual\", generate_random_individual)\n        toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\n        toolbox.register(\"evaluate\", evaluate)\n        toolbox.register(\"mate\", tools.cxUniform, indpb=cxpb)\n\n        # Define parameter-to-choices mapping for mutation\n        param_choices_map = {\n            \"misc_load_multiplier\": misc_load_multiplier_choices,\n            \"heating_setpoint_offset\": heating_setpoint_offset_choices,\n            \"cooling_setpoint_offset\": cooling_setpoint_offset_choices,\n            \"air_leakage_multiplier\": air_leakage_multiplier_choices,\n            \"heating_efficiency_multiplier\": heating_efficiency_multiplier_choices,\n            \"cooling_efficiency_multiplier\": cooling_efficiency_multiplier_choices,\n            \"roof_r_value_multiplier\": roof_r_value_multiplier_choices,\n            \"ceiling_r_value_multiplier\": ceiling_r_value_multiplier_choices,\n            \"above_ground_walls_r_value_multiplier\": above_ground_walls_r_value_multiplier_choices,\n            \"below_ground_walls_r_value_multiplier\": below_ground_walls_r_value_multiplier_choices,\n            \"slab_r_value_multiplier\": slab_r_value_multiplier_choices,\n            \"floor_r_value_multiplier\": floor_r_value_multiplier_choices,\n            \"water_heater_efficiency_multiplier\": water_heater_efficiency_multiplier_choices,\n            \"water_fixtures_usage_multiplier\": water_fixtures_usage_multiplier_choices,\n            \"window_u_factor_multiplier\": window_u_factor_multiplier_choices,\n            \"window_shgc_multiplier\": window_shgc_multiplier_choices,\n            \"appliance_usage_multiplier\": appliance_usage_multiplier_choices,\n            \"lighting_load_multiplier\": lighting_load_multiplier_choices,\n        }\n\n        worst_end_uses_by_gen = []\n\n        end_use_param_map = {\n            \"electricity_heating\": [\n                \"heating_setpoint_offset\",\n                \"air_leakage_multiplier\",\n                \"heating_efficiency_multiplier\",\n                \"roof_r_value_multiplier\",\n                \"ceiling_r_value_multiplier\",\n                \"above_ground_walls_r_value_multiplier\",\n                \"slab_r_value_multiplier\",\n                \"window_u_factor_multiplier\",\n                \"window_shgc_multiplier\",\n            ],\n            \"electricity_cooling\": [\n                \"cooling_setpoint_offset\",\n                \"air_leakage_multiplier\",\n                \"cooling_efficiency_multiplier\",\n                \"roof_r_value_multiplier\",\n                \"ceiling_r_value_multiplier\",\n                \"above_ground_walls_r_value_multiplier\",\n                \"slab_r_value_multiplier\",\n                \"window_u_factor_multiplier\",\n                \"window_shgc_multiplier\",\n            ],\n            \"electricity_baseload\": [\n                \"misc_load_multiplier\",\n                \"appliance_usage_multiplier\",\n                \"lighting_load_multiplier\",\n            ],\n            \"natural_gas_heating\": [\n                \"heating_setpoint_offset\",\n                \"air_leakage_multiplier\",\n                \"heating_efficiency_multiplier\",\n                \"roof_r_value_multiplier\",\n                \"ceiling_r_value_multiplier\",\n                \"above_ground_walls_r_value_multiplier\",\n                \"slab_r_value_multiplier\",\n                \"window_u_factor_multiplier\",\n                \"window_shgc_multiplier\",\n            ],\n            \"natural_gas_baseload\": [\n                \"water_heater_efficiency_multiplier\",\n                \"water_fixtures_usage_multiplier\",\n            ],\n        }\n\n        param_names = list(param_choices_map.keys())\n        name_to_index = {name: idx for idx, name in enumerate(param_names)}\n        index_to_name = {idx: name for name, idx in name_to_index.items()}\n\n        def get_worst_abs_err_end_use(comparison):\n            max_abs_err = -float(\"inf\")\n            worst_end_use_key = None\n            for fuel_type, metrics in comparison.items():\n                for end_use, abs_err in metrics[\"Absolute Error\"].items():\n                    key = f\"{fuel_type}_{end_use}\"\n                    if abs(abs_err) &gt; max_abs_err:\n                        max_abs_err = abs(abs_err)\n                        worst_end_use_key = key\n            return worst_end_use_key\n\n        def adaptive_mutation(individual):\n            mutation_indices = set()\n\n            if worst_end_uses_by_gen:\n                worst_end_use = worst_end_uses_by_gen[-1]\n                impacted_param_names = end_use_param_map.get(worst_end_use, [])\n                if impacted_param_names:\n                    impacted_indices = [\n                        name_to_index[n] for n in impacted_param_names if n in name_to_index\n                    ]\n                    if impacted_indices:\n                        mutation_indices.update(\n                            random.sample(impacted_indices, min(len(impacted_indices), 2))\n                        )\n\n            while len(mutation_indices) &lt; random.randint(3, 6):\n                mutation_indices.add(random.randint(0, len(individual) - 1))\n\n            for i in mutation_indices:\n                current_val = individual[i]\n                param_name = index_to_name[i]\n                choices = [val for val in param_choices_map[param_name] if val != current_val]\n                if choices:\n                    individual[i] = random.choice(choices)\n            return (individual,)\n\n        toolbox.register(\"mutate\", adaptive_mutation)\n        toolbox.register(\"select\", tools.selTournament, tournsize=2)\n\n        calibration_success = False\n\n        if num_proc is None:\n            num_proc = multiprocessing.cpu_count() - 1\n\n        with Pool(\n            processes=num_proc,\n            maxtasksperchild=15,\n            initializer=init_worker,\n            initargs=(global_seed,),\n        ) as pool:\n            toolbox.register(\"map\", pool.map)\n            pop = toolbox.population(n=population_size - 1)\n            pop.append(create_seed_individual())  # Add existing model as seed individual\n            hall_of_fame = tools.HallOfFame(1)\n            stats = tools.Statistics(lambda ind: ind.fitness.values[0])  # noqa: PD011\n            stats.register(\"min\", min)\n            stats.register(\"avg\", lambda x: sum(x) / len(x))\n\n            logbook = tools.Logbook()\n            logbook.header = [\"gen\", \"nevals\", \"min\", \"avg\", \"diversity\"]\n\n            best_bias_series = {}\n            best_abs_series = {}\n\n            # Initial evaluation\n            invalid_ind = [ind for ind in pop if not ind.fitness.valid]\n            fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)\n            for ind, (fit, comp, temp_dir, sim_results) in zip(invalid_ind, fitnesses):\n                ind.fitness.values = fit\n                ind.comparison = comp\n                ind.temp_output_dir = temp_dir\n                ind.sim_results = sim_results\n                if temp_dir is not None:\n                    all_temp_dirs.add(temp_dir)\n\n            # Save all individual hpxmls\n            if temp_dir is not None and Path(temp_dir).exists():\n                gen_dir = output_filepath / \"gen_0\"\n                gen_dir.mkdir(parents=True, exist_ok=True)\n                shutil.copy(\n                    temp_dir / \"modified.xml\",\n                    gen_dir / f\"ind_{uuid.uuid4().hex[:6]}.xml\",\n                )\n\n            # Update Hall of Fame and stats\n            hall_of_fame.update(pop)\n            best_ind = tools.selBest(pop, 1)[0]\n            best_dirs_by_gen.append(getattr(best_ind, \"temp_output_dir\", None))\n\n            # Save best individual bias/abs errors\n            best_comp = best_ind.comparison\n            for end_use, metrics in best_comp.items():\n                for fuel_type, bias_error in metrics[\"Bias Error\"].items():\n                    key = f\"{end_use}_{fuel_type}\"\n                    best_bias_series.setdefault(key, []).append(bias_error)\n                for fuel_type, abs_error in metrics[\"Absolute Error\"].items():\n                    key = f\"{end_use}_{fuel_type}\"\n                    best_abs_series.setdefault(key, []).append(abs_error)\n\n            # Parameter statistics\n            param_stats = {\n                pname: {\n                    \"min\": min(values := [ind[i] for ind in pop]),\n                    \"max\": max(values),\n                    \"median\": statistics.median(values),\n                    \"std\": statistics.pstdev(values) if len(values) &gt; 1 else 0.0,\n                }\n                for i, pname in index_to_name.items()\n            }\n\n            # Simulation result statistics\n            sim_result_stats = {}\n            all_results = {\n                ind.temp_output_dir.stem: ind.sim_results\n                for ind in pop\n                if hasattr(ind, \"sim_results\")\n            }\n            if all_results:\n                fuel_enduse_keys = {\n                    (fuel_type, end_use)\n                    for r in all_results.values()\n                    for fuel_type, end_uses in r.items()\n                    for end_use in end_uses\n                }\n                for fuel_type, end_use in fuel_enduse_keys:\n                    vals = [\n                        r[fuel_type][end_use]\n                        for r in all_results.values()\n                        if fuel_type in r and end_use in r[fuel_type]\n                    ]\n                    if vals:\n                        sim_result_stats[f\"{fuel_type}_{end_use}\"] = calc_stats(vals)\n\n            # Log generation 0\n            record = stats.compile(pop)\n            record.update({f\"bias_error_{k}\": v[-1] for k, v in best_bias_series.items()})\n            record.update({f\"abs_error_{k}\": v[-1] for k, v in best_abs_series.items()})\n            record[\"best_individual\"] = json.dumps(dict(zip(param_choices_map.keys(), best_ind)))\n            record[\"best_individual_sim_results\"] = json.dumps(best_ind.sim_results)\n            record[\"diversity\"] = diversity(pop)\n            record[\"parameter_choice_stats\"] = json.dumps(param_stats)\n            record[\"simulation_result_stats\"] = json.dumps(sim_result_stats)\n            if save_all_results:\n                record[\"all_simulation_results\"] = json.dumps(all_results)\n            logbook.record(gen=0, nevals=len(invalid_ind), **record)\n            print(logbook.stream)\n\n            # Store existing home (seed individual) results\n            existing_home_results = {}\n            for ind in pop:\n                if is_existing_home(ind, param_choices_map):\n                    existing_home_results[\"existing_home_sim_results\"] = json.dumps(ind.sim_results)\n                    break\n\n            # Construct weather-normalized regression model summary\n            _, weather_norm_regression_models = self._process_calibration_results(\n                existing_home_results[\"existing_home_sim_results\"],\n                normalized_consumption_per_bill,\n                for_summary=True,\n            )\n\n            for gen in range(1, generations + 1):\n                # Elitism: Copy the best individuals\n                elite = [copy.deepcopy(ind) for ind in tools.selBest(pop, k=1)]\n\n                # Generate offspring\n                offspring = algorithms.varAnd(pop, toolbox, cxpb=cxpb, mutpb=mutpb)\n\n                # Evaluate offspring\n                invalid_ind = [ind for ind in offspring if not ind.fitness.valid]\n                fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)\n                for ind, (fit, comp, temp_dir, sim_results) in zip(invalid_ind, fitnesses):\n                    ind.fitness.values = fit\n                    ind.comparison = comp\n                    ind.temp_output_dir = temp_dir\n                    ind.sim_results = sim_results\n                    all_temp_dirs.add(temp_dir)\n\n                # Select next generation (excluding elites), then add elites\n                if invalid_ind:\n                    worst_key = get_worst_abs_err_end_use(invalid_ind[0].comparison)\n                    worst_end_uses_by_gen.append(worst_key)\n\n                pop = toolbox.select(offspring, population_size - len(elite))\n                pop.extend(elite)\n\n                # Save all individual hpxmls\n                if temp_dir is not None and Path(temp_dir).exists():\n                    gen_dir = output_filepath / f\"gen_{gen}\"\n                    gen_dir.mkdir(parents=True, exist_ok=True)\n                    shutil.copy(\n                        temp_dir / \"modified.xml\",\n                        gen_dir / f\"ind_{uuid.uuid4().hex[:6]}.xml\",\n                    )\n\n                # Update Hall of Fame and stats\n                hall_of_fame.update(pop)\n                best_ind = tools.selBest(pop, 1)[0]\n                best_dirs_by_gen.append(getattr(best_ind, \"temp_output_dir\", None))\n\n                # Save hall of fame bias/abs errors\n                best_comp = best_ind.comparison\n                for end_use, metrics in best_comp.items():\n                    for fuel_type, bias_error in metrics[\"Bias Error\"].items():\n                        key = f\"{end_use}_{fuel_type}\"\n                        best_bias_series.setdefault(key, []).append(bias_error)\n                    for fuel_type, abs_error in metrics[\"Absolute Error\"].items():\n                        key = f\"{end_use}_{fuel_type}\"\n                        best_abs_series.setdefault(key, []).append(abs_error)\n\n                # Parameter statistics\n                param_stats = {\n                    pname: {\n                        \"min\": min(values := [ind[i] for ind in pop]),\n                        \"max\": max(values),\n                        \"median\": statistics.median(values),\n                        \"std\": statistics.pstdev(values) if len(values) &gt; 1 else 0.0,\n                    }\n                    for i, pname in index_to_name.items()\n                }\n\n                # Simulation result statistics\n                sim_result_stats = {}\n                all_results = {\n                    ind.temp_output_dir.stem: ind.sim_results\n                    for ind in pop\n                    if hasattr(ind, \"sim_results\")\n                }\n                if all_results:\n                    fuel_enduse_keys = {\n                        (fuel_type, end_use)\n                        for r in all_results.values()\n                        for fuel_type, end_uses in r.items()\n                        for end_use in end_uses\n                    }\n                    for fuel_type, end_use in fuel_enduse_keys:\n                        vals = [\n                            r[fuel_type][end_use]\n                            for r in all_results.values()\n                            if fuel_type in r and end_use in r[fuel_type]\n                        ]\n                        if vals:\n                            sim_result_stats[f\"{fuel_type}_{end_use}\"] = calc_stats(vals)\n\n                # Log the current generation\n                record = stats.compile(pop)\n                record.update({f\"bias_error_{k}\": v[-1] for k, v in best_bias_series.items()})\n                record.update({f\"abs_error_{k}\": v[-1] for k, v in best_abs_series.items()})\n                record[\"best_individual\"] = json.dumps(\n                    dict(zip(param_choices_map.keys(), best_ind))\n                )\n                record[\"best_individual_sim_results\"] = json.dumps(best_ind.sim_results)\n                record[\"diversity\"] = diversity(pop)\n                record[\"parameter_choice_stats\"] = json.dumps(param_stats)\n                record[\"simulation_result_stats\"] = json.dumps(sim_result_stats)\n                if save_all_results:\n                    record[\"all_simulation_results\"] = json.dumps(all_results)\n                logbook.record(gen=gen, nevals=len(invalid_ind), **record)\n                print(logbook.stream)\n\n                # Early termination conditions\n                if meets_termination_criteria(best_comp):\n                    calibration_success = True\n                    break\n\n        best_individual = hall_of_fame[0]\n        best_individual_dict = dict(zip(param_choices_map.keys(), best_individual))\n\n        best_individual_hpxml = best_individual.temp_output_dir / \"modified.xml\"\n        if best_individual_hpxml.exists():\n            shutil.copy(best_individual_hpxml, output_filepath / \"best_individual.xml\")\n\n        # Cleanup\n        time.sleep(0.5)\n        for temp_dir in all_temp_dirs:\n            if temp_dir and Path(temp_dir).exists():\n                shutil.rmtree(temp_dir, ignore_errors=True)\n\n        if calibration_success:\n            print(\"Search completed successfully.\")\n        else:\n            print(\n                \"Search completed unsuccessfully. No solution found before reaching the maximum number of generations.\"\n            )\n\n        return (\n            best_individual_dict,\n            pop,\n            logbook,\n            best_bias_series,\n            best_abs_series,\n            weather_norm_regression_models,\n            existing_home_results,\n            calibration_success,\n        )\n</code></pre>"},{"location":"code_documentation/calibrate/#src.openstudio_hpxml_calibration.calibrate.Calibrate.__init__","title":"<code>__init__(original_hpxml_filepath, csv_bills_filepath=None, config_filepath=None)</code>","text":"<p>Initialize the Calibrate class.</p> <p>Parameters:</p> Name Type Description Default <code>original_hpxml_filepath</code> <code>Path</code> <p>Path to the original HPXML file.</p> required <code>csv_bills_filepath</code> <code>Path | None</code> <p>Optional path to the utility bills CSV file.</p> <code>None</code> <code>config_filepath</code> <code>Path | None</code> <p>Optional path to the configuration file.</p> <code>None</code> Source code in <code>src/openstudio_hpxml_calibration/calibrate.py</code> <pre><code>def __init__(\n    self,\n    original_hpxml_filepath: Path,\n    csv_bills_filepath: Path | None = None,\n    config_filepath: Path | None = None,\n):\n    \"\"\"Initialize the Calibrate class.\n\n    :param original_hpxml_filepath: Path to the original HPXML file.\n    :type original_hpxml_filepath: Path\n    :param csv_bills_filepath: Optional path to the utility bills CSV file.\n    :type csv_bills_filepath: Path | None, optional\n    :param config_filepath: Optional path to the configuration file.\n    :type config_filepath: Path | None, optional\n    \"\"\"\n    self.hpxml_filepath = Path(original_hpxml_filepath).resolve()\n    self.hpxml = HpxmlDoc(Path(original_hpxml_filepath).resolve())\n    self.ga_config = _load_config(config_filepath)\n\n    if csv_bills_filepath:\n        logger.debug(f\"Adding utility data from {csv_bills_filepath} to hpxml\")\n        self.hpxml = set_consumption_on_hpxml(self.hpxml, csv_bills_filepath)\n\n    self.hpxml.hpxml_data_error_checking(self.ga_config)\n</code></pre>"},{"location":"code_documentation/calibrate/#src.openstudio_hpxml_calibration.calibrate.Calibrate.compare_results","title":"<code>compare_results(normalized_consumption, annual_model_results)</code>","text":"<p>Compare the normalized consumption with the model results.</p> <p>Parameters:</p> Name Type Description Default <code>normalized_consumption</code> <code>dict[str, DataFrame]</code> <p>Normalized consumption data (MBtu).</p> required <code>annual_model_results</code> <code>dict</code> <p>Model results data (MBtu).</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, dict[str, float]]]</code> <p>Comparison results containing bias and absolute errors for each fuel type and end use.</p> Source code in <code>src/openstudio_hpxml_calibration/calibrate.py</code> <pre><code>def compare_results(\n    self, normalized_consumption: dict[str, pd.DataFrame], annual_model_results\n) -&gt; dict[str, dict[str, dict[str, float]]]:\n    \"\"\"Compare the normalized consumption with the model results.\n\n    :param normalized_consumption: Normalized consumption data (MBtu).\n    :type normalized_consumption: dict[str, pd.DataFrame]\n    :param annual_model_results: Model results data (MBtu).\n    :type annual_model_results: dict\n    :return: Comparison results containing bias and absolute errors for each fuel type and end use.\n    :rtype: dict[str, dict[str, dict[str, float]]]\n    \"\"\"\n\n    # Build annual normalized bill consumption dicts\n    annual_normalized_bill_consumption = {}\n    for fuel_type, consumption in normalized_consumption.items():\n        annual_normalized_bill_consumption[fuel_type] = {}\n        for end_use in [\"heating\", \"cooling\", \"baseload\"]:\n            if (\n                end_use not in annual_model_results[fuel_type]\n                or annual_model_results[fuel_type][end_use] == 0.0\n            ):\n                continue\n            annual_normalized_bill_consumption[fuel_type][end_use] = (\n                consumption[end_use].sum().round(1)\n            )\n\n    comparison_results = {}\n\n    # combine the annual normalized bill consumption with the model results\n    for model_fuel_type, disagg_results in annual_model_results.items():\n        if model_fuel_type in annual_normalized_bill_consumption:\n            comparison_results[model_fuel_type] = {\"Bias Error\": {}, \"Absolute Error\": {}}\n            for load_type in disagg_results:\n                if load_type not in annual_normalized_bill_consumption[model_fuel_type]:\n                    continue\n\n                disagg_result = disagg_results[load_type]\n                if model_fuel_type == \"electricity\":\n                    # All results from simulation and normalized bills are in MBtu.\n                    # convert electric loads from MBtu to kWh for bpi2400\n                    annual_normalized_bill_consumption[model_fuel_type][load_type] = (\n                        convert_units(\n                            annual_normalized_bill_consumption[model_fuel_type][load_type],\n                            from_=\"mbtu\",\n                            to_=\"kwh\",\n                        )\n                    )\n                    disagg_result = convert_units(disagg_result, from_=\"mbtu\", to_=\"kwh\")\n\n                # Calculate error levels\n                if annual_normalized_bill_consumption[model_fuel_type][load_type] == 0:\n                    comparison_results[model_fuel_type][\"Bias Error\"][load_type] = float(\"nan\")\n                else:\n                    comparison_results[model_fuel_type][\"Bias Error\"][load_type] = round(\n                        (\n                            (\n                                annual_normalized_bill_consumption[model_fuel_type][load_type]\n                                - disagg_result\n                            )\n                            / annual_normalized_bill_consumption[model_fuel_type][load_type]\n                        )\n                        * 100,\n                        1,\n                    )\n                comparison_results[model_fuel_type][\"Absolute Error\"][load_type] = round(\n                    abs(\n                        annual_normalized_bill_consumption[model_fuel_type][load_type]\n                        - disagg_result\n                    ),\n                    1,\n                )\n\n    return comparison_results\n</code></pre>"},{"location":"code_documentation/calibrate/#src.openstudio_hpxml_calibration.calibrate.Calibrate.get_model_results","title":"<code>get_model_results(json_results_path)</code>","text":"<p>Retrieve annual energy usage from the HPXML model.</p> <p>Parameters:</p> Name Type Description Default <code>json_results_path</code> <code>Path</code> <p>Path to the JSON file containing annual results from the HPXML model.</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, float]]</code> <p>Model results for each fuel type by end use in MBtu.</p> Source code in <code>src/openstudio_hpxml_calibration/calibrate.py</code> <pre><code>def get_model_results(self, json_results_path: Path) -&gt; dict[str, dict[str, float]]:\n    \"\"\"Retrieve annual energy usage from the HPXML model.\n\n    :param json_results_path: Path to the JSON file containing annual results from the HPXML model.\n    :type json_results_path: Path\n    :return: Model results for each fuel type by end use in MBtu.\n    :rtype: dict[str, dict[str, float]]\n    \"\"\"\n\n    results = json.loads(json_results_path.read_text())\n    if \"Time\" in results:\n        raise ValueError(f\"your file {json_results_path} is not an annual results file\")\n\n    model_output = {\n        \"electricity\": {},\n        \"natural gas\": {},\n        \"propane\": {},\n        \"fuel oil\": {},\n        \"wood cord\": {},\n        \"wood pellets\": {},\n        \"coal\": {},\n    }\n\n    for end_use, consumption in results[\"End Use\"].items():\n        fuel_type = end_use.split(\":\")[0].lower().strip()\n        # ignore electricity usage for heating (fans/pumps) when electricity is not the fuel type for any heating system\n        if (\n            fuel_type == \"electricity\"\n            and \"Heating\" in end_use\n            and FuelType.ELECTRICITY.value not in self.hpxml.get_fuel_types()[\"heating\"]\n        ):\n            continue\n        if \"Heating\" in end_use:\n            model_output[fuel_type][\"heating\"] = round(\n                number=(model_output[fuel_type].get(\"heating\", 0) + consumption), ndigits=3\n            )\n        elif \"Cooling\" in end_use:\n            model_output[fuel_type][\"cooling\"] = round(\n                number=(model_output[fuel_type].get(\"cooling\", 0) + consumption), ndigits=3\n            )\n        else:\n            model_output[fuel_type][\"baseload\"] = round(\n                number=(model_output[fuel_type].get(\"baseload\", 0) + consumption), ndigits=3\n            )\n\n    return model_output\n</code></pre>"},{"location":"code_documentation/calibrate/#src.openstudio_hpxml_calibration.calibrate.Calibrate.get_normalized_consumption_per_bill","title":"<code>get_normalized_consumption_per_bill()</code>","text":"<p>Get the normalized consumption for the building.</p> <p>Returns:</p> Type Description <code>dict[FuelType, pd.DataFrame]</code> <p>Dictionary containing dataframes for the normalized consumption by end use and fuel type, in MBtu.</p> Source code in <code>src/openstudio_hpxml_calibration/calibrate.py</code> <pre><code>def get_normalized_consumption_per_bill(self) -&gt; dict[FuelType, pd.DataFrame]:\n    \"\"\"Get the normalized consumption for the building.\n\n    :return: Dictionary containing dataframes for the normalized consumption by end use and fuel type, in MBtu.\n    :rtype: dict[FuelType, pd.DataFrame]\n    \"\"\"\n\n    normalized_consumption = {}\n    # InverseModel is not applicable to delivered fuels, so we only use it for electricity and natural gas\n    self.inv_model = InverseModel(self.hpxml, user_config=self.ga_config)\n    for fuel_type, bills in self.inv_model.bills_by_fuel_type.items():\n        if fuel_type in (\n            FuelType.FUEL_OIL,\n            FuelType.PROPANE,\n            FuelType.WOOD,\n            FuelType.WOOD_PELLETS,\n        ):\n            continue  # Delivered fuels have a separate calibration process: simplified_annual_usage()\n\n        def _calculate_wrapped_total(row):\n            \"\"\"Extract the epw_daily rows that correspond to the bill month\n\n            Search by row index because epw_daily is just 365 entries without dates\n            \"\"\"\n            start = row[\"start_day_of_year\"]\n            end = row[\"end_day_of_year\"]\n\n            if start &lt;= end:\n                subset = epw_daily_mbtu.iloc[start:end].sum()\n            else:\n                # handle bills that wrap around the end of the year\n                part1 = epw_daily_mbtu.iloc[start:].sum()\n                part2 = epw_daily_mbtu.iloc[0:end].sum()\n                subset = pd.concat(objs=[part1, part2])\n                subset = subset[~subset.index.duplicated()]\n\n            return subset\n\n        try:\n            predicted_daily_btu = self.inv_model.predict_epw_daily(fuel_type=fuel_type)\n            epw_daily_kbtu = convert_units(x=predicted_daily_btu, from_=\"btu\", to_=\"kbtu\")\n\n            epw_daily_mbtu = convert_units(epw_daily_kbtu, from_=\"kbtu\", to_=\"mbtu\")\n\n            normalized_consumption[fuel_type.value] = pd.DataFrame(\n                data=bills.apply(_calculate_wrapped_total, axis=1)\n            )\n            normalized_consumption[fuel_type.value][\"start_date\"] = bills[\"start_date\"]\n            normalized_consumption[fuel_type.value][\"end_date\"] = bills[\"end_date\"]\n        except Bpi2400ModelFitError:\n            continue\n\n    return normalized_consumption\n</code></pre>"},{"location":"code_documentation/calibrate/#src.openstudio_hpxml_calibration.calibrate.Calibrate.run_search","title":"<code>run_search(population_size=None, generations=None, cxpb=None, mutpb=None, num_proc=None, output_filepath=None, save_all_results=False)</code>","text":"<p>Run the genetic algorithm search for calibration.</p> <p>Parameters:</p> Name Type Description Default <code>population_size</code> <code>(int, optional)</code> <p>Number of individuals in the population.</p> <code>None</code> <code>generations</code> <code>(int, optional)</code> <p>Number of generations to run.</p> <code>None</code> <code>cxpb</code> <code>(float, optional)</code> <p>Crossover probability.</p> <code>None</code> <code>mutpb</code> <code>(float, optional)</code> <p>Mutation probability.</p> <code>None</code> <code>num_proc</code> <code>(int, optional)</code> <p>Number of parallel processes to use.</p> <code>None</code> <code>output_filepath</code> <code>(Path, optional)</code> <p>Directory to save output files.</p> <code>None</code> <code>save_all_results</code> <code>(bool, optional)</code> <p>If True, saves all simulation results.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple containing best individual, population, logbook, error series, regression models, and results.</p> Source code in <code>src/openstudio_hpxml_calibration/calibrate.py</code> <pre><code>def run_search(\n    self,\n    population_size=None,\n    generations=None,\n    cxpb=None,\n    mutpb=None,\n    num_proc=None,\n    output_filepath=None,\n    save_all_results=False,\n):\n    \"\"\"Run the genetic algorithm search for calibration.\n\n    :param population_size: Number of individuals in the population.\n    :type population_size: int, optional\n    :param generations: Number of generations to run.\n    :type generations: int, optional\n    :param cxpb: Crossover probability.\n    :type cxpb: float, optional\n    :param mutpb: Mutation probability.\n    :type mutpb: float, optional\n    :param num_proc: Number of parallel processes to use.\n    :type num_proc: int, optional\n    :param output_filepath: Directory to save output files.\n    :type output_filepath: Path, optional\n    :param save_all_results: If True, saves all simulation results.\n    :type save_all_results: bool, optional\n    :return: Tuple containing best individual, population, logbook, error series, regression models, and results.\n    :rtype: tuple\n    \"\"\"\n    print(f\"Running search algorithm for '{Path(self.hpxml_filepath).name}'...\")\n\n    all_temp_dirs = set()\n    best_dirs_by_gen = []\n    cfg = self.ga_config\n    population_size = cfg[\"genetic_algorithm\"][\"population_size\"]\n    generations = cfg[\"genetic_algorithm\"][\"generations\"]\n    bias_error_threshold = cfg[\"acceptance_criteria\"][\"bias_error_threshold\"]\n    abs_error_elec_threshold = cfg[\"acceptance_criteria\"][\"abs_error_elec_threshold\"]\n    abs_error_fuel_threshold = cfg[\"acceptance_criteria\"][\"abs_error_fuel_threshold\"]\n    cxpb = cfg[\"genetic_algorithm\"][\"crossover_probability\"]\n    mutpb = cfg[\"genetic_algorithm\"][\"mutation_probability\"]\n    misc_load_multiplier_choices = cfg[\"value_choices\"][\"misc_load_multiplier_choices\"]\n    air_leakage_multiplier_choices = cfg[\"value_choices\"][\"air_leakage_multiplier_choices\"]\n    heating_efficiency_multiplier_choices = cfg[\"value_choices\"][\n        \"heating_efficiency_multiplier_choices\"\n    ]\n    cooling_efficiency_multiplier_choices = cfg[\"value_choices\"][\n        \"cooling_efficiency_multiplier_choices\"\n    ]\n    roof_r_value_multiplier_choices = cfg[\"value_choices\"][\"roof_r_value_multiplier_choices\"]\n    ceiling_r_value_multiplier_choices = cfg[\"value_choices\"][\n        \"ceiling_r_value_multiplier_choices\"\n    ]\n    above_ground_walls_r_value_multiplier_choices = cfg[\"value_choices\"][\n        \"above_ground_walls_r_value_multiplier_choices\"\n    ]\n    below_ground_walls_r_value_multiplier_choices = cfg[\"value_choices\"][\n        \"below_ground_walls_r_value_multiplier_choices\"\n    ]\n    slab_r_value_multiplier_choices = cfg[\"value_choices\"][\"slab_r_value_multiplier_choices\"]\n    floor_r_value_multiplier_choices = cfg[\"value_choices\"][\"floor_r_value_multiplier_choices\"]\n    heating_setpoint_offset_choices = cfg[\"value_choices\"][\"heating_setpoint_offset_choices\"]\n    cooling_setpoint_offset_choices = cfg[\"value_choices\"][\"cooling_setpoint_offset_choices\"]\n    water_heater_efficiency_multiplier_choices = cfg[\"value_choices\"][\n        \"water_heater_efficiency_multiplier_choices\"\n    ]\n    water_fixtures_usage_multiplier_choices = cfg[\"value_choices\"][\n        \"water_fixtures_usage_multiplier_choices\"\n    ]\n    window_u_factor_multiplier_choices = cfg[\"value_choices\"][\n        \"window_u_factor_multiplier_choices\"\n    ]\n    window_shgc_multiplier_choices = cfg[\"value_choices\"][\"window_shgc_multiplier_choices\"]\n    appliance_usage_multiplier_choices = cfg[\"value_choices\"][\n        \"appliance_usage_multiplier_choices\"\n    ]\n    lighting_load_multiplier_choices = cfg[\"value_choices\"][\"lighting_load_multiplier_choices\"]\n\n    normalized_consumption_per_bill = self.get_normalized_consumption_per_bill()\n\n    def evaluate(individual):\n        try:\n            (\n                misc_load_multiplier,\n                heating_setpoint_offset,\n                cooling_setpoint_offset,\n                air_leakage_multiplier,\n                heating_efficiency_multiplier,\n                cooling_efficiency_multiplier,\n                roof_r_value_multiplier,\n                ceiling_r_value_multiplier,\n                above_ground_walls_r_value_multiplier,\n                below_ground_walls_r_value_multiplier,\n                slab_r_value_multiplier,\n                floor_r_value_multiplier,\n                water_heater_efficiency_multiplier,\n                water_fixtures_usage_multiplier,\n                window_u_factor_multiplier,\n                window_shgc_multiplier,\n                appliance_usage_multiplier,\n                lighting_load_multiplier,\n            ) = individual\n            temp_output_dir = Path(\n                tempfile.mkdtemp(prefix=f\"calib_test_{uuid.uuid4().hex[:6]}_\")\n            )\n            mod_hpxml_path = temp_output_dir / \"modified.xml\"\n            arguments = {\n                \"xml_file_path\": str(self.hpxml_filepath),\n                \"save_file_path\": str(mod_hpxml_path),\n                \"misc_load_multiplier\": misc_load_multiplier,\n                \"heating_setpoint_offset\": heating_setpoint_offset,\n                \"cooling_setpoint_offset\": cooling_setpoint_offset,\n                \"air_leakage_multiplier\": air_leakage_multiplier,\n                \"heating_efficiency_multiplier\": heating_efficiency_multiplier,\n                \"cooling_efficiency_multiplier\": cooling_efficiency_multiplier,\n                \"roof_r_value_multiplier\": roof_r_value_multiplier,\n                \"ceiling_r_value_multiplier\": ceiling_r_value_multiplier,\n                \"above_ground_walls_r_value_multiplier\": above_ground_walls_r_value_multiplier,\n                \"below_ground_walls_r_value_multiplier\": below_ground_walls_r_value_multiplier,\n                \"slab_r_value_multiplier\": slab_r_value_multiplier,\n                \"floor_r_value_multiplier\": floor_r_value_multiplier,\n                \"water_heater_efficiency_multiplier\": water_heater_efficiency_multiplier,\n                \"water_fixtures_usage_multiplier\": water_fixtures_usage_multiplier,\n                \"window_u_factor_multiplier\": window_u_factor_multiplier,\n                \"window_shgc_multiplier\": window_shgc_multiplier,\n                \"appliance_usage_multiplier\": appliance_usage_multiplier,\n                \"lighting_load_multiplier\": lighting_load_multiplier,\n            }\n\n            temp_osw = Path(temp_output_dir / \"modify_hpxml.osw\")\n            self.create_measure_input_file(arguments, temp_osw)\n\n            app([\"modify-xml\", str(temp_osw)])\n            app(\n                [\n                    \"run-sim\",\n                    str(mod_hpxml_path),\n                    \"--output-dir\",\n                    str(temp_output_dir),\n                    \"--output-format\",\n                    \"json\",\n                ]\n            )\n\n            output_file = temp_output_dir / \"run\" / \"results_annual.json\"\n            simulation_results = self.get_model_results(json_results_path=output_file)\n            comparison, _ = self._process_calibration_results(\n                simulation_results, normalized_consumption_per_bill\n            )\n\n            for model_fuel_type, result in comparison.items():\n                bias_error_criteria = self.ga_config[\"acceptance_criteria\"][\n                    \"bias_error_threshold\"\n                ]\n                if model_fuel_type == \"electricity\":\n                    absolute_error_criteria = self.ga_config[\"acceptance_criteria\"][\n                        \"abs_error_elec_threshold\"\n                    ]\n                else:\n                    absolute_error_criteria = self.ga_config[\"acceptance_criteria\"][\n                        \"abs_error_fuel_threshold\"\n                    ]\n                for load_type in result[\"Bias Error\"]:\n                    if abs(result[\"Bias Error\"][load_type]) &gt; bias_error_criteria:\n                        logger.debug(\n                            f\"Bias error for {model_fuel_type} {load_type} is {result['Bias Error'][load_type]} but the limit is +/- {bias_error_criteria}\"\n                        )\n                    if abs(result[\"Absolute Error\"][load_type]) &gt; absolute_error_criteria:\n                        logger.debug(\n                            f\"Absolute error for {model_fuel_type} {load_type} is {result['Absolute Error'][load_type]} but the limit is +/- {absolute_error_criteria}\"\n                        )\n\n            combined_error_penalties = []\n            for fuel_type, metrics in comparison.items():\n                for end_use, bias_error in metrics[\"Bias Error\"].items():\n                    if math.isnan(bias_error) or math.isnan(metrics[\"Absolute Error\"][end_use]):\n                        continue  # Skip NaN values\n\n                    bias_err = abs(bias_error)\n                    abs_err = abs(metrics[\"Absolute Error\"][end_use])\n\n                    log_bias_err = math.log1p(bias_err)  # log1p to avoid log(0)\n                    log_abs_err = math.log1p(abs_err)\n\n                    bias_error_penalty = max(0, log_bias_err) ** 2\n                    abs_error_penalty = max(0, log_abs_err) ** 2\n                    combined_error_penalty = bias_error_penalty + abs_error_penalty\n\n                    combined_error_penalties.append(combined_error_penalty)\n\n            total_score = sum(combined_error_penalties)\n\n            return (\n                (total_score,),\n                comparison,\n                temp_output_dir,\n                simulation_results,\n            )\n\n        except Exception as e:\n            logger.error(f\"Error evaluating individual {individual}: {e}\")\n            return (float(\"inf\"),), {}, None\n\n    def abs_error_within_threshold(\n        fuel_type: str, abs_error: float, elec_threshold: float, fuel_threshold: float\n    ) -&gt; bool:\n        if fuel_type == \"electricity\":\n            return abs(abs_error) &lt;= elec_threshold\n        else:\n            return abs(abs_error) &lt;= fuel_threshold\n\n    def diversity(pop):\n        return len({tuple(ind) for ind in pop}) / len(pop)\n\n    def calc_stats(values):\n        if not values:\n            return {\"min\": None, \"max\": None, \"median\": None, \"std\": None}\n        return {\n            \"min\": min(values),\n            \"max\": max(values),\n            \"median\": statistics.median(values),\n            \"std\": statistics.pstdev(values) if len(values) &gt; 1 else 0.0,\n        }\n\n    def meets_termination_criteria(comparison):\n        all_bias_err_limit_met = True\n        all_abs_err_limit_met = True\n        for fuel_type, metrics in comparison.items():\n            for end_use in metrics[\"Bias Error\"]:\n                bias_err = metrics[\"Bias Error\"][end_use]\n                abs_err = metrics[\"Absolute Error\"][end_use]\n\n                # Check bias error\n                if abs(bias_err) &gt; bias_error_threshold:\n                    all_bias_err_limit_met = False\n\n                # Check absolute error\n                if not abs_error_within_threshold(\n                    fuel_type,\n                    abs_err,\n                    abs_error_elec_threshold,\n                    abs_error_fuel_threshold,\n                ):\n                    all_abs_err_limit_met = False\n\n        return all_bias_err_limit_met or all_abs_err_limit_met\n\n    toolbox = base.Toolbox()\n    toolbox.register(\"attr_misc_load_multiplier\", random.choice, misc_load_multiplier_choices)\n    toolbox.register(\n        \"attr_heating_setpoint_offset\", random.choice, heating_setpoint_offset_choices\n    )\n    toolbox.register(\n        \"attr_cooling_setpoint_offset\", random.choice, cooling_setpoint_offset_choices\n    )\n    toolbox.register(\n        \"attr_air_leakage_multiplier\", random.choice, air_leakage_multiplier_choices\n    )\n    toolbox.register(\n        \"attr_heating_efficiency_multiplier\",\n        random.choice,\n        heating_efficiency_multiplier_choices,\n    )\n    toolbox.register(\n        \"attr_cooling_efficiency_multiplier\",\n        random.choice,\n        cooling_efficiency_multiplier_choices,\n    )\n    toolbox.register(\n        \"attr_roof_r_value_multiplier\", random.choice, roof_r_value_multiplier_choices\n    )\n    toolbox.register(\n        \"attr_ceiling_r_value_multiplier\", random.choice, ceiling_r_value_multiplier_choices\n    )\n    toolbox.register(\n        \"attr_above_ground_walls_r_value_multiplier\",\n        random.choice,\n        above_ground_walls_r_value_multiplier_choices,\n    )\n    toolbox.register(\n        \"attr_below_ground_walls_r_value_multiplier\",\n        random.choice,\n        below_ground_walls_r_value_multiplier_choices,\n    )\n    toolbox.register(\n        \"attr_slab_r_value_multiplier\", random.choice, slab_r_value_multiplier_choices\n    )\n    toolbox.register(\n        \"attr_floor_r_value_multiplier\", random.choice, floor_r_value_multiplier_choices\n    )\n    toolbox.register(\n        \"attr_water_heater_efficiency_multiplier\",\n        random.choice,\n        water_heater_efficiency_multiplier_choices,\n    )\n    toolbox.register(\n        \"attr_water_fixtures_usage_multiplier\",\n        random.choice,\n        water_fixtures_usage_multiplier_choices,\n    )\n    toolbox.register(\n        \"attr_window_u_factor_multiplier\", random.choice, window_u_factor_multiplier_choices\n    )\n    toolbox.register(\n        \"attr_window_shgc_multiplier\", random.choice, window_shgc_multiplier_choices\n    )\n    toolbox.register(\n        \"attr_appliance_usage_multiplier\", random.choice, appliance_usage_multiplier_choices\n    )\n    toolbox.register(\n        \"attr_lighting_load_multiplier\", random.choice, lighting_load_multiplier_choices\n    )\n    toolbox.register(\n        \"individual\",\n        tools.initRepeat,\n        creator.Individual,\n        (\n            toolbox.attr_misc_load_multiplier,\n            toolbox.attr_heating_setpoint_offset,\n            toolbox.attr_cooling_setpoint_offset,\n            toolbox.attr_air_leakage_multiplier,\n            toolbox.attr_heating_efficiency_multiplier,\n            toolbox.attr_cooling_efficiency_multiplier,\n            toolbox.attr_roof_r_value_multiplier,\n            toolbox.attr_ceiling_r_value_multiplier,\n            toolbox.attr_above_ground_walls_r_value_multiplier,\n            toolbox.attr_below_ground_walls_r_value_multiplier,\n            toolbox.attr_slab_r_value_multiplier,\n            toolbox.attr_floor_r_value_multiplier,\n            toolbox.attr_water_heater_efficiency_multiplier,\n            toolbox.attr_water_fixtures_usage_multiplier,\n            toolbox.attr_window_u_factor_multiplier,\n            toolbox.attr_window_shgc_multiplier,\n            toolbox.attr_appliance_usage_multiplier,\n            toolbox.attr_lighting_load_multiplier,\n        ),\n        n=18,\n    )\n\n    def create_seed_individual():\n        return creator.Individual(\n            [\n                1,  # misc_load_multiplier\n                0,  # heating_setpoint_offset\n                0,  # cooling_setpoint_offset\n                1,  # air_leakage_multiplier\n                1,  # heating_efficiency_multiplier\n                1,  # cooling_efficiency_multiplier\n                1,  # roof_r_value_multiplier\n                1,  # ceiling_r_value_multiplier\n                1,  # above_ground_walls_r_value_multiplier\n                1,  # below_ground_walls_r_value_multiplier\n                1,  # slab_r_value_multiplier\n                1,  # floor_r_value_multiplier\n                1,  # water_heater_efficiency_multiplier\n                1,  # water_fixtures_usage_multiplier\n                1,  # window_u_factor_multiplier\n                1,  # window_shgc_multiplier\n                1,  # appliance_usage_multiplier\n                1,  # lighting_load_multiplier\n            ]\n        )\n\n    def generate_random_individual():\n        return creator.Individual(\n            [\n                random.choice(misc_load_multiplier_choices),\n                random.choice(heating_setpoint_offset_choices),\n                random.choice(cooling_setpoint_offset_choices),\n                random.choice(air_leakage_multiplier_choices),\n                random.choice(heating_efficiency_multiplier_choices),\n                random.choice(cooling_efficiency_multiplier_choices),\n                random.choice(roof_r_value_multiplier_choices),\n                random.choice(ceiling_r_value_multiplier_choices),\n                random.choice(above_ground_walls_r_value_multiplier_choices),\n                random.choice(below_ground_walls_r_value_multiplier_choices),\n                random.choice(slab_r_value_multiplier_choices),\n                random.choice(floor_r_value_multiplier_choices),\n                random.choice(water_heater_efficiency_multiplier_choices),\n                random.choice(water_fixtures_usage_multiplier_choices),\n                random.choice(window_u_factor_multiplier_choices),\n                random.choice(window_shgc_multiplier_choices),\n                random.choice(appliance_usage_multiplier_choices),\n                random.choice(lighting_load_multiplier_choices),\n            ]\n        )\n\n    def is_existing_home(individual, param_choices_map):\n        return all(\n            val == 1\n            for key, val in zip(param_choices_map.keys(), individual)\n            if \"multiplier\" in key\n        ) and all(\n            val == 0\n            for key, val in zip(param_choices_map.keys(), individual)\n            if \"offset\" in key\n        )\n\n    toolbox.register(\"individual\", generate_random_individual)\n    toolbox.register(\"population\", tools.initRepeat, list, toolbox.individual)\n    toolbox.register(\"evaluate\", evaluate)\n    toolbox.register(\"mate\", tools.cxUniform, indpb=cxpb)\n\n    # Define parameter-to-choices mapping for mutation\n    param_choices_map = {\n        \"misc_load_multiplier\": misc_load_multiplier_choices,\n        \"heating_setpoint_offset\": heating_setpoint_offset_choices,\n        \"cooling_setpoint_offset\": cooling_setpoint_offset_choices,\n        \"air_leakage_multiplier\": air_leakage_multiplier_choices,\n        \"heating_efficiency_multiplier\": heating_efficiency_multiplier_choices,\n        \"cooling_efficiency_multiplier\": cooling_efficiency_multiplier_choices,\n        \"roof_r_value_multiplier\": roof_r_value_multiplier_choices,\n        \"ceiling_r_value_multiplier\": ceiling_r_value_multiplier_choices,\n        \"above_ground_walls_r_value_multiplier\": above_ground_walls_r_value_multiplier_choices,\n        \"below_ground_walls_r_value_multiplier\": below_ground_walls_r_value_multiplier_choices,\n        \"slab_r_value_multiplier\": slab_r_value_multiplier_choices,\n        \"floor_r_value_multiplier\": floor_r_value_multiplier_choices,\n        \"water_heater_efficiency_multiplier\": water_heater_efficiency_multiplier_choices,\n        \"water_fixtures_usage_multiplier\": water_fixtures_usage_multiplier_choices,\n        \"window_u_factor_multiplier\": window_u_factor_multiplier_choices,\n        \"window_shgc_multiplier\": window_shgc_multiplier_choices,\n        \"appliance_usage_multiplier\": appliance_usage_multiplier_choices,\n        \"lighting_load_multiplier\": lighting_load_multiplier_choices,\n    }\n\n    worst_end_uses_by_gen = []\n\n    end_use_param_map = {\n        \"electricity_heating\": [\n            \"heating_setpoint_offset\",\n            \"air_leakage_multiplier\",\n            \"heating_efficiency_multiplier\",\n            \"roof_r_value_multiplier\",\n            \"ceiling_r_value_multiplier\",\n            \"above_ground_walls_r_value_multiplier\",\n            \"slab_r_value_multiplier\",\n            \"window_u_factor_multiplier\",\n            \"window_shgc_multiplier\",\n        ],\n        \"electricity_cooling\": [\n            \"cooling_setpoint_offset\",\n            \"air_leakage_multiplier\",\n            \"cooling_efficiency_multiplier\",\n            \"roof_r_value_multiplier\",\n            \"ceiling_r_value_multiplier\",\n            \"above_ground_walls_r_value_multiplier\",\n            \"slab_r_value_multiplier\",\n            \"window_u_factor_multiplier\",\n            \"window_shgc_multiplier\",\n        ],\n        \"electricity_baseload\": [\n            \"misc_load_multiplier\",\n            \"appliance_usage_multiplier\",\n            \"lighting_load_multiplier\",\n        ],\n        \"natural_gas_heating\": [\n            \"heating_setpoint_offset\",\n            \"air_leakage_multiplier\",\n            \"heating_efficiency_multiplier\",\n            \"roof_r_value_multiplier\",\n            \"ceiling_r_value_multiplier\",\n            \"above_ground_walls_r_value_multiplier\",\n            \"slab_r_value_multiplier\",\n            \"window_u_factor_multiplier\",\n            \"window_shgc_multiplier\",\n        ],\n        \"natural_gas_baseload\": [\n            \"water_heater_efficiency_multiplier\",\n            \"water_fixtures_usage_multiplier\",\n        ],\n    }\n\n    param_names = list(param_choices_map.keys())\n    name_to_index = {name: idx for idx, name in enumerate(param_names)}\n    index_to_name = {idx: name for name, idx in name_to_index.items()}\n\n    def get_worst_abs_err_end_use(comparison):\n        max_abs_err = -float(\"inf\")\n        worst_end_use_key = None\n        for fuel_type, metrics in comparison.items():\n            for end_use, abs_err in metrics[\"Absolute Error\"].items():\n                key = f\"{fuel_type}_{end_use}\"\n                if abs(abs_err) &gt; max_abs_err:\n                    max_abs_err = abs(abs_err)\n                    worst_end_use_key = key\n        return worst_end_use_key\n\n    def adaptive_mutation(individual):\n        mutation_indices = set()\n\n        if worst_end_uses_by_gen:\n            worst_end_use = worst_end_uses_by_gen[-1]\n            impacted_param_names = end_use_param_map.get(worst_end_use, [])\n            if impacted_param_names:\n                impacted_indices = [\n                    name_to_index[n] for n in impacted_param_names if n in name_to_index\n                ]\n                if impacted_indices:\n                    mutation_indices.update(\n                        random.sample(impacted_indices, min(len(impacted_indices), 2))\n                    )\n\n        while len(mutation_indices) &lt; random.randint(3, 6):\n            mutation_indices.add(random.randint(0, len(individual) - 1))\n\n        for i in mutation_indices:\n            current_val = individual[i]\n            param_name = index_to_name[i]\n            choices = [val for val in param_choices_map[param_name] if val != current_val]\n            if choices:\n                individual[i] = random.choice(choices)\n        return (individual,)\n\n    toolbox.register(\"mutate\", adaptive_mutation)\n    toolbox.register(\"select\", tools.selTournament, tournsize=2)\n\n    calibration_success = False\n\n    if num_proc is None:\n        num_proc = multiprocessing.cpu_count() - 1\n\n    with Pool(\n        processes=num_proc,\n        maxtasksperchild=15,\n        initializer=init_worker,\n        initargs=(global_seed,),\n    ) as pool:\n        toolbox.register(\"map\", pool.map)\n        pop = toolbox.population(n=population_size - 1)\n        pop.append(create_seed_individual())  # Add existing model as seed individual\n        hall_of_fame = tools.HallOfFame(1)\n        stats = tools.Statistics(lambda ind: ind.fitness.values[0])  # noqa: PD011\n        stats.register(\"min\", min)\n        stats.register(\"avg\", lambda x: sum(x) / len(x))\n\n        logbook = tools.Logbook()\n        logbook.header = [\"gen\", \"nevals\", \"min\", \"avg\", \"diversity\"]\n\n        best_bias_series = {}\n        best_abs_series = {}\n\n        # Initial evaluation\n        invalid_ind = [ind for ind in pop if not ind.fitness.valid]\n        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)\n        for ind, (fit, comp, temp_dir, sim_results) in zip(invalid_ind, fitnesses):\n            ind.fitness.values = fit\n            ind.comparison = comp\n            ind.temp_output_dir = temp_dir\n            ind.sim_results = sim_results\n            if temp_dir is not None:\n                all_temp_dirs.add(temp_dir)\n\n        # Save all individual hpxmls\n        if temp_dir is not None and Path(temp_dir).exists():\n            gen_dir = output_filepath / \"gen_0\"\n            gen_dir.mkdir(parents=True, exist_ok=True)\n            shutil.copy(\n                temp_dir / \"modified.xml\",\n                gen_dir / f\"ind_{uuid.uuid4().hex[:6]}.xml\",\n            )\n\n        # Update Hall of Fame and stats\n        hall_of_fame.update(pop)\n        best_ind = tools.selBest(pop, 1)[0]\n        best_dirs_by_gen.append(getattr(best_ind, \"temp_output_dir\", None))\n\n        # Save best individual bias/abs errors\n        best_comp = best_ind.comparison\n        for end_use, metrics in best_comp.items():\n            for fuel_type, bias_error in metrics[\"Bias Error\"].items():\n                key = f\"{end_use}_{fuel_type}\"\n                best_bias_series.setdefault(key, []).append(bias_error)\n            for fuel_type, abs_error in metrics[\"Absolute Error\"].items():\n                key = f\"{end_use}_{fuel_type}\"\n                best_abs_series.setdefault(key, []).append(abs_error)\n\n        # Parameter statistics\n        param_stats = {\n            pname: {\n                \"min\": min(values := [ind[i] for ind in pop]),\n                \"max\": max(values),\n                \"median\": statistics.median(values),\n                \"std\": statistics.pstdev(values) if len(values) &gt; 1 else 0.0,\n            }\n            for i, pname in index_to_name.items()\n        }\n\n        # Simulation result statistics\n        sim_result_stats = {}\n        all_results = {\n            ind.temp_output_dir.stem: ind.sim_results\n            for ind in pop\n            if hasattr(ind, \"sim_results\")\n        }\n        if all_results:\n            fuel_enduse_keys = {\n                (fuel_type, end_use)\n                for r in all_results.values()\n                for fuel_type, end_uses in r.items()\n                for end_use in end_uses\n            }\n            for fuel_type, end_use in fuel_enduse_keys:\n                vals = [\n                    r[fuel_type][end_use]\n                    for r in all_results.values()\n                    if fuel_type in r and end_use in r[fuel_type]\n                ]\n                if vals:\n                    sim_result_stats[f\"{fuel_type}_{end_use}\"] = calc_stats(vals)\n\n        # Log generation 0\n        record = stats.compile(pop)\n        record.update({f\"bias_error_{k}\": v[-1] for k, v in best_bias_series.items()})\n        record.update({f\"abs_error_{k}\": v[-1] for k, v in best_abs_series.items()})\n        record[\"best_individual\"] = json.dumps(dict(zip(param_choices_map.keys(), best_ind)))\n        record[\"best_individual_sim_results\"] = json.dumps(best_ind.sim_results)\n        record[\"diversity\"] = diversity(pop)\n        record[\"parameter_choice_stats\"] = json.dumps(param_stats)\n        record[\"simulation_result_stats\"] = json.dumps(sim_result_stats)\n        if save_all_results:\n            record[\"all_simulation_results\"] = json.dumps(all_results)\n        logbook.record(gen=0, nevals=len(invalid_ind), **record)\n        print(logbook.stream)\n\n        # Store existing home (seed individual) results\n        existing_home_results = {}\n        for ind in pop:\n            if is_existing_home(ind, param_choices_map):\n                existing_home_results[\"existing_home_sim_results\"] = json.dumps(ind.sim_results)\n                break\n\n        # Construct weather-normalized regression model summary\n        _, weather_norm_regression_models = self._process_calibration_results(\n            existing_home_results[\"existing_home_sim_results\"],\n            normalized_consumption_per_bill,\n            for_summary=True,\n        )\n\n        for gen in range(1, generations + 1):\n            # Elitism: Copy the best individuals\n            elite = [copy.deepcopy(ind) for ind in tools.selBest(pop, k=1)]\n\n            # Generate offspring\n            offspring = algorithms.varAnd(pop, toolbox, cxpb=cxpb, mutpb=mutpb)\n\n            # Evaluate offspring\n            invalid_ind = [ind for ind in offspring if not ind.fitness.valid]\n            fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)\n            for ind, (fit, comp, temp_dir, sim_results) in zip(invalid_ind, fitnesses):\n                ind.fitness.values = fit\n                ind.comparison = comp\n                ind.temp_output_dir = temp_dir\n                ind.sim_results = sim_results\n                all_temp_dirs.add(temp_dir)\n\n            # Select next generation (excluding elites), then add elites\n            if invalid_ind:\n                worst_key = get_worst_abs_err_end_use(invalid_ind[0].comparison)\n                worst_end_uses_by_gen.append(worst_key)\n\n            pop = toolbox.select(offspring, population_size - len(elite))\n            pop.extend(elite)\n\n            # Save all individual hpxmls\n            if temp_dir is not None and Path(temp_dir).exists():\n                gen_dir = output_filepath / f\"gen_{gen}\"\n                gen_dir.mkdir(parents=True, exist_ok=True)\n                shutil.copy(\n                    temp_dir / \"modified.xml\",\n                    gen_dir / f\"ind_{uuid.uuid4().hex[:6]}.xml\",\n                )\n\n            # Update Hall of Fame and stats\n            hall_of_fame.update(pop)\n            best_ind = tools.selBest(pop, 1)[0]\n            best_dirs_by_gen.append(getattr(best_ind, \"temp_output_dir\", None))\n\n            # Save hall of fame bias/abs errors\n            best_comp = best_ind.comparison\n            for end_use, metrics in best_comp.items():\n                for fuel_type, bias_error in metrics[\"Bias Error\"].items():\n                    key = f\"{end_use}_{fuel_type}\"\n                    best_bias_series.setdefault(key, []).append(bias_error)\n                for fuel_type, abs_error in metrics[\"Absolute Error\"].items():\n                    key = f\"{end_use}_{fuel_type}\"\n                    best_abs_series.setdefault(key, []).append(abs_error)\n\n            # Parameter statistics\n            param_stats = {\n                pname: {\n                    \"min\": min(values := [ind[i] for ind in pop]),\n                    \"max\": max(values),\n                    \"median\": statistics.median(values),\n                    \"std\": statistics.pstdev(values) if len(values) &gt; 1 else 0.0,\n                }\n                for i, pname in index_to_name.items()\n            }\n\n            # Simulation result statistics\n            sim_result_stats = {}\n            all_results = {\n                ind.temp_output_dir.stem: ind.sim_results\n                for ind in pop\n                if hasattr(ind, \"sim_results\")\n            }\n            if all_results:\n                fuel_enduse_keys = {\n                    (fuel_type, end_use)\n                    for r in all_results.values()\n                    for fuel_type, end_uses in r.items()\n                    for end_use in end_uses\n                }\n                for fuel_type, end_use in fuel_enduse_keys:\n                    vals = [\n                        r[fuel_type][end_use]\n                        for r in all_results.values()\n                        if fuel_type in r and end_use in r[fuel_type]\n                    ]\n                    if vals:\n                        sim_result_stats[f\"{fuel_type}_{end_use}\"] = calc_stats(vals)\n\n            # Log the current generation\n            record = stats.compile(pop)\n            record.update({f\"bias_error_{k}\": v[-1] for k, v in best_bias_series.items()})\n            record.update({f\"abs_error_{k}\": v[-1] for k, v in best_abs_series.items()})\n            record[\"best_individual\"] = json.dumps(\n                dict(zip(param_choices_map.keys(), best_ind))\n            )\n            record[\"best_individual_sim_results\"] = json.dumps(best_ind.sim_results)\n            record[\"diversity\"] = diversity(pop)\n            record[\"parameter_choice_stats\"] = json.dumps(param_stats)\n            record[\"simulation_result_stats\"] = json.dumps(sim_result_stats)\n            if save_all_results:\n                record[\"all_simulation_results\"] = json.dumps(all_results)\n            logbook.record(gen=gen, nevals=len(invalid_ind), **record)\n            print(logbook.stream)\n\n            # Early termination conditions\n            if meets_termination_criteria(best_comp):\n                calibration_success = True\n                break\n\n    best_individual = hall_of_fame[0]\n    best_individual_dict = dict(zip(param_choices_map.keys(), best_individual))\n\n    best_individual_hpxml = best_individual.temp_output_dir / \"modified.xml\"\n    if best_individual_hpxml.exists():\n        shutil.copy(best_individual_hpxml, output_filepath / \"best_individual.xml\")\n\n    # Cleanup\n    time.sleep(0.5)\n    for temp_dir in all_temp_dirs:\n        if temp_dir and Path(temp_dir).exists():\n            shutil.rmtree(temp_dir, ignore_errors=True)\n\n    if calibration_success:\n        print(\"Search completed successfully.\")\n    else:\n        print(\n            \"Search completed unsuccessfully. No solution found before reaching the maximum number of generations.\"\n        )\n\n    return (\n        best_individual_dict,\n        pop,\n        logbook,\n        best_bias_series,\n        best_abs_series,\n        weather_norm_regression_models,\n        existing_home_results,\n        calibration_success,\n    )\n</code></pre>"},{"location":"code_documentation/calibrate/#src.openstudio_hpxml_calibration.calibrate.Calibrate.simplified_annual_usage","title":"<code>simplified_annual_usage(model_results, delivered_consumption, fuel_type)</code>","text":"<p>Perform simplified annual usage calibration for delivered fuels.</p> <p>Estimates annual fuel usage and compares measured consumption with modeled results for fuels that cannot be weather-normalized (e.g., fuel oil, propane, wood). Calculates bias and absolute errors for baseload, heating, and cooling end uses.</p> <p>Parameters:</p> Name Type Description Default <code>model_results</code> <code>dict</code> <p>Annual model results by fuel type and end use.</p> required <code>delivered_consumption</code> <code>object</code> <p>Consumption data object for the delivered fuel.</p> required <code>fuel_type</code> <code>str</code> <p>The fuel type being calibrated.</p> required <p>Returns:</p> Type Description <code>tuple[dict, dict]</code> <p>Tuple containing bias and absolute error metrics for each end use, and weather-normalized annual consumption by end use.</p> Source code in <code>src/openstudio_hpxml_calibration/calibrate.py</code> <pre><code>def simplified_annual_usage(\n    self, model_results: dict, delivered_consumption, fuel_type: str\n) -&gt; dict:\n    \"\"\"Perform simplified annual usage calibration for delivered fuels.\n\n    Estimates annual fuel usage and compares measured consumption with modeled results\n    for fuels that cannot be weather-normalized (e.g., fuel oil, propane, wood).\n    Calculates bias and absolute errors for baseload, heating, and cooling end uses.\n\n    :param model_results: Annual model results by fuel type and end use.\n    :type model_results: dict\n    :param delivered_consumption: Consumption data object for the delivered fuel.\n    :type delivered_consumption: object\n    :param fuel_type: The fuel type being calibrated.\n    :type fuel_type: str\n    :return: Tuple containing bias and absolute error metrics for each end use, and weather-normalized annual consumption by end use.\n    :rtype: tuple[dict, dict]\n    \"\"\"\n    total_period_tmy_dd, total_period_actual_dd = calculate_annual_degree_days(self.hpxml)\n\n    comparison_results = {}\n    if isinstance(model_results, str):\n        model_results = json.loads(model_results)\n\n    measured_consumption = 0.0\n    fuel_unit_type = delivered_consumption.ConsumptionType.Energy.UnitofMeasure\n    if delivered_consumption.ConsumptionType.Energy.FuelType == fuel_type:\n        first_bill_date = delivered_consumption.ConsumptionDetail[0].StartDateTime\n        last_bill_date = delivered_consumption.ConsumptionDetail[-1].EndDateTime\n        first_bill_date = dt.strptime(str(first_bill_date), \"%Y-%m-%dT%H:%M:%S\")\n        last_bill_date = dt.strptime(str(last_bill_date), \"%Y-%m-%dT%H:%M:%S\")\n        num_days = (last_bill_date - first_bill_date + timedelta(days=1)).days\n        for period_consumption in delivered_consumption.ConsumptionDetail:\n            measured_consumption += float(period_consumption.Consumption)\n        # logger.debug(\n        #     f\"Measured {fuel_type} consumption: {measured_consumption:,.2f} {fuel_unit_type}\"\n        # )\n        if fuel_unit_type == \"gal\" and fuel_type == FuelType.FUEL_OIL.value:\n            fuel_unit_type = f\"{fuel_unit_type}_fuel_oil\"\n        elif fuel_unit_type == \"gal\" and fuel_type == FuelType.PROPANE.value:\n            fuel_unit_type = f\"{fuel_unit_type}_propane\"\n        elif fuel_unit_type == \"therms\":\n            fuel_unit_type = \"therm\"\n    measured_consumption = convert_units(measured_consumption, str(fuel_unit_type), \"mBtu\")\n\n    modeled_baseload = model_results[fuel_type].get(\"baseload\", 0)\n    modeled_heating = model_results[fuel_type].get(\"heating\", 0)\n    modeled_cooling = model_results[fuel_type].get(\"cooling\", 0)\n    total_modeled_usage = modeled_baseload + modeled_heating + modeled_cooling\n\n    baseload_fraction = modeled_baseload / total_modeled_usage\n    heating_fraction = modeled_heating / total_modeled_usage\n    cooling_fraction = modeled_cooling / total_modeled_usage\n\n    baseload = baseload_fraction * (num_days / 365)\n    heating = heating_fraction * (\n        total_period_actual_dd[fuel_type][\"HDD65F\"] / total_period_tmy_dd[fuel_type][\"HDD65F\"]\n    )\n    cooling = cooling_fraction * (\n        total_period_actual_dd[fuel_type][\"CDD65F\"] / total_period_tmy_dd[fuel_type][\"CDD65F\"]\n    )\n\n    annual_delivered_fuel_usage = measured_consumption / (baseload + heating + cooling)\n    # logger.debug(f\"annual_delivered_fuel_usage: {annual_delivered_fuel_usage:,.2f} mBtu\")\n\n    normalized_annual_baseload = annual_delivered_fuel_usage * baseload_fraction\n    normalized_annual_heating = annual_delivered_fuel_usage * heating_fraction\n    normalized_annual_cooling = annual_delivered_fuel_usage * cooling_fraction\n\n    baseload_bias_error = (\n        ((normalized_annual_baseload - modeled_baseload) / normalized_annual_baseload) * 100\n        if normalized_annual_baseload\n        else 0\n    )\n    heating_bias_error = (\n        ((normalized_annual_heating - modeled_heating) / normalized_annual_heating) * 100\n        if normalized_annual_heating\n        else 0\n    )\n    cooling_bias_error = (\n        ((normalized_annual_cooling - modeled_cooling) / normalized_annual_cooling) * 100\n        if normalized_annual_cooling\n        else 0\n    )\n\n    baseload_absolute_error = abs(normalized_annual_baseload - modeled_baseload)\n    heating_absolute_error = abs(normalized_annual_heating - modeled_heating)\n    cooling_absolute_error = abs(normalized_annual_cooling - modeled_cooling)\n\n    comparison_results[fuel_type] = {\n        \"Bias Error\": {\n            \"baseload\": round(baseload_bias_error, 2),\n            \"heating\": round(heating_bias_error, 2),\n            \"cooling\": round(cooling_bias_error, 2),\n        },\n        \"Absolute Error\": {\n            \"baseload\": round(baseload_absolute_error, 2),\n            \"heating\": round(heating_absolute_error, 2),\n            \"cooling\": round(cooling_absolute_error, 2),\n        },\n    }\n    normalized_annual_end_uses = {\n        \"baseload\": round(normalized_annual_baseload, 2),\n        \"heating\": round(normalized_annual_heating, 2),\n        \"cooling\": round(normalized_annual_cooling, 2),\n    }\n    return comparison_results, normalized_annual_end_uses\n</code></pre>"},{"location":"code_documentation/calibrate/#src.openstudio_hpxml_calibration.calibrate.init_worker","title":"<code>init_worker(seed)</code>","text":"<p>Initialize the random seed for a worker process.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int</code> <p>The base seed to use for randomization.</p> required Source code in <code>src/openstudio_hpxml_calibration/calibrate.py</code> <pre><code>def init_worker(seed):\n    \"\"\"Initialize the random seed for a worker process.\n\n    :param seed: The base seed to use for randomization.\n    :type seed: int\n    \"\"\"\n    worker_id = (\n        multiprocessing.current_process()._identity[0]\n        if multiprocessing.current_process()._identity\n        else 0\n    )\n    random.seed(seed + worker_id)\n</code></pre>"},{"location":"code_documentation/hpxml/","title":"HPXML","text":""},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc","title":"<code>HpxmlDoc</code>","text":"<p>A class representing an HPXML document.</p> <p>Attributes can be accessed using the lxml.objectify syntax. i.e. hpxml = HpxmlDoc(\"filename.xml\") hpxml.Building.Site.Address</p> <p>There are a number of helper functions to get other important information.</p> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>class HpxmlDoc:\n    \"\"\"\n    A class representing an HPXML document.\n\n    Attributes can be accessed using the lxml.objectify syntax. i.e.\n    hpxml = HpxmlDoc(\"filename.xml\")\n    hpxml.Building.Site.Address\n\n    There are a number of helper functions to get other important information.\n    \"\"\"\n\n    def __init__(\n        self, filename: os.PathLike, validate_schema: bool = True, validate_schematron: bool = True\n    ):\n        \"\"\"Create an HpxmlDoc object\n\n        :param filename: Path to file to parse\n        :type filename: os.PathLike\n        :param validate_schema: Validate against the HPXML schema, defaults to True\n        :type validate_schema: bool, optional\n        :param validate_schematron: Validate against EPvalidator schematron, defaults to True\n        :type validate_schematron: bool, optional\n        \"\"\"\n        self.file_path = Path(filename).resolve()\n        self.tree = objectify.parse(str(filename))\n        self.root = self.tree.getroot()\n        self.ns = {\"h\": self.root.nsmap.get(\"h\", self.root.nsmap.get(None))}\n\n        if validate_schema:\n            hpxml_schema_filename = (\n                OS_HPXML_PATH / \"HPXMLtoOpenStudio\" / \"resources\" / \"hpxml_schema\" / \"HPXML.xsd\"\n            )\n            schema_doc = etree.parse(str(hpxml_schema_filename))\n            schema = etree.XMLSchema(schema_doc)\n            schema.assertValid(self.tree)\n\n        if validate_schematron:\n            hpxml_schematron_filename = (\n                OS_HPXML_PATH\n                / \"HPXMLtoOpenStudio\"\n                / \"resources\"\n                / \"hpxml_schematron\"\n                / \"EPvalidator.sch\"\n            )\n            schematron_doc = etree.parse(str(hpxml_schematron_filename))\n            schematron = isoschematron.Schematron(schematron_doc)\n            schematron.assertValid(self.tree)\n\n    def __getattr__(self, name: str):\n        # This prevents infinite recursion in contexts involving logging or multiprocessing\n        if name == \"root\":\n            raise AttributeError(\"Avoid recursive getattr call on root\")\n        return getattr(self.root, name)\n\n    def xpath(\n        self, xpath_expr: str, el: objectify.ObjectifiedElement | None = None, **kw\n    ) -&gt; list[objectify.ObjectifiedElement]:\n        \"\"\"Run an xpath query on the file\n\n        The h: namespace is the default HPXML namespace. No namespaces need to\n        be passed into the function.\n\n        ``hpxml.xpath(\"//h:Wall\")``\n\n        :param xpath_expr: Xpath expression to evaluate\n        :type xpath_expr: str\n        :param el: Optional element from which to evaluate the xpath, if omitted\n            will use the root HPXML element.\n        :type el: objectify.ObjectifiedElement | None, optional\n        :return: A list of elements that match the xpath expression.\n        :rtype: list[objectify.ObjectifiedElement]\n        \"\"\"\n        if el is None:\n            el = self.root\n        ns = re.match(r\"\\{(.+)\\}\", el.tag).group(1)\n        return el.xpath(xpath_expr, namespaces={\"h\": ns}, **kw)\n\n    def get_first_building_id(self) -&gt; str:\n        \"\"\"Get the id of the first Building element in the file.\"\"\"\n        return self.xpath(\"h:Building[1]/h:BuildingID/@id\", smart_strings=False)[0]\n\n    def get_building(self, building_id: str | None = None) -&gt; objectify.ObjectifiedElement:\n        \"\"\"Get a building element\n\n        :param building_id: The id of the Building to retrieve, gets first one if missing\n        :type building_id: str | None, optional\n        :return: Building element\n        :rtype: objectify.ObjectifiedElement\n        \"\"\"\n        if building_id is None:\n            return self.xpath(\"h:Building[1]\")[0]\n        else:\n            return self.xpath(\"h:Building[h:BuildingID/@id=$building_id]\", building_id=building_id)[\n                0\n            ]\n\n    def get_fuel_types(self, building_id: str | None = None) -&gt; tuple[str, set[str]]:\n        \"\"\"Get fuel types providing heating, cooling, water heating, clothes drying, and cooking\n\n        :param building_id: The id of the Building to retrieve, gets first one if missing\n        :type building_id: str\n        :return: fuel types for heating, cooling, water heaters, clothes dryers, and cooking\n        :rtype: tuple[str, set[str]]\n        \"\"\"\n\n        building = self.get_building(building_id)\n        fuel_types = {\n            \"heating\": set(),\n            \"cooling\": set(),\n            \"water heater\": set(),\n            \"clothes dryer\": set(),\n            \"cooking\": set(),\n        }\n        if (\n            hasattr(building.BuildingDetails, \"Systems\")\n            and hasattr(building.BuildingDetails.Systems, \"HVAC\")\n            and hasattr(building.BuildingDetails.Systems.HVAC, \"HVACPlant\")\n        ):\n            for hvac_system in building.BuildingDetails.Systems.HVAC.HVACPlant:\n                if hasattr(hvac_system, \"HeatingSystem\") and hasattr(\n                    hvac_system.HeatingSystem, \"HeatingSystemFuel\"\n                ):\n                    fuel_types[\"heating\"].add(\n                        hvac_system.HeatingSystem.HeatingSystemFuel.text.strip()\n                    )\n\n                if hasattr(hvac_system, \"CoolingSystem\"):\n                    if hasattr(hvac_system.CoolingSystem, \"CoolingSystemFuel\"):\n                        fuel_types[\"cooling\"].add(\n                            hvac_system.CoolingSystem.CoolingSystemFuel.text.strip()\n                        )\n                    if hasattr(hvac_system.CoolingSystem, \"IntegratedHeatingSystemFuel\"):\n                        fuel_types[\"heating\"].add(\n                            hvac_system.CoolingSystem.IntegratedHeatingSystemFuel.text.strip()\n                        )\n\n                if hasattr(hvac_system, \"HeatPump\"):\n                    if hasattr(hvac_system.HeatPump, \"HeatPumpFuel\"):\n                        fuel_types[\"heating\"].add(hvac_system.HeatPump.HeatPumpFuel.text.strip())\n                        fuel_types[\"cooling\"].add(hvac_system.HeatPump.HeatPumpFuel.text.strip())\n                    if hasattr(hvac_system.HeatPump, \"BackupSystemFuel\"):\n                        fuel_types[\"heating\"].add(\n                            hvac_system.HeatPump.BackupSystemFuel.text.strip()\n                        )\n\n        if (\n            hasattr(building.BuildingDetails, \"Systems\")\n            and hasattr(building.BuildingDetails.Systems, \"WaterHeating\")\n            and hasattr(building.BuildingDetails.Systems.WaterHeating, \"WaterHeatingSystem\")\n        ):\n            for water_heater in building.BuildingDetails.Systems.WaterHeating.WaterHeatingSystem:\n                if hasattr(water_heater, \"FuelType\"):\n                    fuel_types[\"water heater\"].add(water_heater.FuelType.text.strip())\n                elif hasattr(water_heater, \"RelatedHVACSystem\"):\n                    # No need to retrieve, we already have the fuel type for the heating system\n                    pass\n\n        if hasattr(building.BuildingDetails, \"Appliances\") and hasattr(\n            building.BuildingDetails.Appliances, \"ClothesDryer\"\n        ):\n            for clothes_dryer in building.BuildingDetails.Appliances.ClothesDryer:\n                if hasattr(clothes_dryer, \"FuelType\"):\n                    fuel_types[\"clothes dryer\"].add(clothes_dryer.FuelType.text.strip())\n\n        if hasattr(building.BuildingDetails, \"Appliances\") and hasattr(\n            building.BuildingDetails.Appliances, \"CookingRange\"\n        ):\n            for cooking_range in building.BuildingDetails.Appliances.CookingRange:\n                if hasattr(cooking_range, \"FuelType\"):\n                    fuel_types[\"cooking\"].add(cooking_range.FuelType.text.strip())\n\n        return fuel_types\n\n    def get_consumptions(\n        self, building_id: str | None = None\n    ) -&gt; tuple[objectify.ObjectifiedElement, ...]:\n        \"\"\"Get all Consumption elements for a building\n\n        :param building_id: The id of the Building to retrieve, gets first one if missing\n        :type building_id: str | None, optional\n        :return: Tuple of Consumption elements\n        :rtype: tuple\n        \"\"\"\n        if building_id is None:\n            return tuple(self.xpath(\"h:Consumption\"))\n        return tuple(\n            self.xpath(\"h:Consumption[h:BuildingID/@idref=$building_id]\", building_id=building_id)\n        )\n\n    @functools.cache\n    def get_epw_path(self, building_id: str | None = None) -&gt; Path:\n        \"\"\"Get the filesystem path to the EPW file.\n\n        Uses the same logic as OpenStudio-HPXML\n\n        :param building_id: The id of the Building to retrieve, gets first one if missing\n        :type building_id: str | None, optional\n        :raises FileNotFoundError: Raises this error if the epw file doesn't exist\n        :return: path to epw file\n        :rtype: Path\n        \"\"\"\n        building = self.get_building(building_id)\n        try:\n            epw_file = str(\n                building.BuildingDetails.ClimateandRiskZones.WeatherStation.extension.EPWFilePath\n            )\n        except AttributeError:\n            zipcode = str(building.Site.Address.ZipCode).zfill(5)\n            zipcode_lookup_filename = (\n                OS_HPXML_PATH / \"HPXMLtoOpenStudio/resources/data/zipcode_weather_stations.csv\"\n            )\n            zipcodes = pd.read_csv(\n                zipcode_lookup_filename,\n                usecols=[\"zipcode\", \"station_filename\"],\n                index_col=\"zipcode\",\n                dtype={\"zipcode\": str},\n            )\n            epw_file = zipcodes.loc[zipcode, \"station_filename\"]\n\n        epw_path = Path(epw_file)\n        if not epw_path.is_absolute():\n            possible_parent_paths = [self.file_path.parent, OS_HPXML_PATH / \"weather\"]\n            for parent_path in possible_parent_paths:\n                epw_path = parent_path / Path(epw_file)\n                if epw_path.exists():\n                    break\n        if not epw_path.exists():\n            raise FileNotFoundError(str(epw_path))\n\n        return epw_path\n\n    @functools.cache\n    def get_epw_data(self, building_id: str | None = None, **kw) -&gt; tuple[pd.DataFrame, dict]:\n        \"\"\"Get the epw data as a dataframe\n\n        :param building_id: The id of the Building to retrieve, gets first one if missing\n        :type building_id: str | None, optional\n        :return: Dataframe of epw and a dict of epw metadata\n        :rtype: tuple[pd.DataFrame, dict]\n        \"\"\"\n        return read_epw(self.get_epw_path(building_id), **kw)\n\n    def get_lat_lon(self, building_id: str | None = None) -&gt; tuple[float, float]:\n        \"\"\"Get latitude, longitude from hpxml file\n\n        :param building_id: Optional building_id of the building you want to get location for.\n        :type building_id: str | None\n        :return: Latitude and longitude\n        :rtype: tuple[float, float]\n        \"\"\"\n        building = self.get_building(building_id)\n        try:\n            # Option 1: Get directly from HPXML\n            geolocation = building.Site.GeoLocation\n            lat = float(geolocation.Latitude)\n            lon = float(geolocation.Longitude)\n        except AttributeError:\n            _, epw_metadata = self.get_epw_data(building_id)\n            lat = epw_metadata[\"latitude\"]\n            lon = epw_metadata[\"longitude\"]\n\n        return lat, lon\n\n    def hpxml_data_error_checking(self, config: dict) -&gt; None:\n        \"\"\"Check for common HPXML errors\n\n        :param config: Configuration dictionary, combination of default and user config\n        :type config: dict\n\n        :raises ValueError: If an error is found\n        \"\"\"\n        now = dt.now()\n        building = self.get_building()\n        consumptions = self.get_consumptions()\n\n        # Check that the building doesn't have PV\n        try:\n            building.BuildingDetails.Systems.Photovoltaics\n            raise ValueError(\"PV is not supported with automated calibration at this time.\")\n        except AttributeError:\n            pass\n\n        # Helper: flatten all fuel entries across all consumption elements\n        all_fuels = [\n            (consumption_elem, fuel)\n            for consumption_elem in consumptions\n            for fuel in consumption_elem.ConsumptionDetails.ConsumptionInfo\n        ]\n\n        # Check that every fuel in every consumption element has a ConsumptionType.Energy element\n        if not all(\n            all(\n                hasattr(fuel.ConsumptionType, \"Energy\")\n                for fuel in consumption_elem.ConsumptionDetails.ConsumptionInfo\n            )\n            for consumption_elem in consumptions\n        ):\n            raise ValueError(\n                \"Every fuel in every Consumption section must have a valid ConsumptionType.Energy element.\"\n            )\n\n        # Check that at least one consumption element matches the building ID\n        if not any(\n            consumption_elem.BuildingID.attrib[\"idref\"] == building.BuildingID.attrib[\"id\"]\n            for consumption_elem in consumptions\n        ):\n            raise ValueError(\"No Consumption section matches the Building ID in the HPXML file.\")\n\n        # Check that at least one fuel per fuel type has valid units\n        def valid_unit(fuel):\n            fuel_type = fuel.ConsumptionType.Energy.FuelType\n            unit = fuel.ConsumptionType.Energy.UnitofMeasure\n            match fuel_type:\n                case FuelType.ELECTRICITY.value:\n                    return unit in (\"kWh\", \"MWh\")\n                case FuelType.NATURAL_GAS.value:\n                    return unit in (\"therms\", \"Btu\", \"kBtu\", \"MBtu\", \"ccf\", \"kcf\", \"Mcf\")\n                case FuelType.FUEL_OIL.value | FuelType.PROPANE.value:\n                    return unit in (\"gal\", \"Btu\", \"kBtu\", \"MBtu\", \"therms\")\n                case _:\n                    return False\n\n        for fuel_type in {\n            getattr(fuel.ConsumptionType.Energy, \"FuelType\", None)\n            for _, fuel in all_fuels\n            if hasattr(fuel.ConsumptionType, \"Energy\")\n        }:\n            if fuel_type is None:\n                continue\n            if not any(\n                getattr(fuel.ConsumptionType.Energy, \"FuelType\", None) == fuel_type\n                and valid_unit(fuel)\n                for _, fuel in all_fuels\n            ):\n                raise ValueError(\n                    f\"No valid unit found for fuel type '{fuel_type}' in any Consumption section.\"\n                )\n\n        # Check that for each fuel type, there is only one Consumption section\n        fuel_type_to_consumption = {}\n        for consumption_elem in consumptions:\n            for fuel in consumption_elem.ConsumptionDetails.ConsumptionInfo:\n                fuel_type = getattr(fuel.ConsumptionType.Energy, \"FuelType\", None)\n                if fuel_type is None:\n                    continue\n                if fuel_type in fuel_type_to_consumption:\n                    raise ValueError(\n                        f\"Multiple Consumption sections found for fuel type '{fuel_type}'. \"\n                        \"Only one section per fuel type is allowed.\"\n                    )\n                fuel_type_to_consumption[fuel_type] = consumption_elem\n\n        # Check that electricity consumption is present in at least one section\n        if not any(\n            getattr(fuel.ConsumptionType.Energy, \"FuelType\", None) == FuelType.ELECTRICITY.value\n            for _, fuel in all_fuels\n        ):\n            raise ValueError(\n                \"Electricity consumption is required for calibration. \"\n                \"Please provide electricity consumption data in the HPXML file.\"\n            )\n\n        # Check that for each fuel, all periods are consecutive, non-overlapping, and valid\n        for _, fuel in all_fuels:\n            details = getattr(fuel, \"ConsumptionDetail\", [])\n            for i, detail in enumerate(details):\n                try:\n                    start_date = dt.strptime(str(detail.StartDateTime), \"%Y-%m-%dT%H:%M:%S\")\n                except AttributeError:\n                    raise ValueError(\n                        f\"Consumption detail {i} for {fuel.ConsumptionType.Energy.FuelType} is missing StartDateTime.\"\n                    )\n                try:\n                    end_date = dt.strptime(str(detail.EndDateTime), \"%Y-%m-%dT%H:%M:%S\")\n                except AttributeError:\n                    raise ValueError(\n                        f\"Consumption detail {i} for {fuel.ConsumptionType.Energy.FuelType} is missing EndDateTime.\"\n                    )\n                if i &gt; 0:\n                    prev_detail = details[i - 1]\n                    prev_end = dt.strptime(str(prev_detail.EndDateTime), \"%Y-%m-%dT%H:%M:%S\")\n                    curr_start = dt.strptime(str(detail.StartDateTime), \"%Y-%m-%dT%H:%M:%S\")\n                    if curr_start &lt; prev_end:\n                        raise ValueError(\n                            f\"Consumption details for {fuel.ConsumptionType.Energy.FuelType} overlap: \"\n                            f\"{prev_detail.StartDateTime} - {prev_detail.EndDateTime} overlaps with \"\n                            f\"{detail.StartDateTime} - {detail.EndDateTime}\"\n                        )\n                    if (curr_start - prev_end) &gt; timedelta(minutes=1):\n                        raise ValueError(\n                            f\"Gap in consumption data for {fuel.ConsumptionType.Energy.FuelType}: \"\n                            f\"Period between {prev_detail.EndDateTime} and {detail.StartDateTime} is not covered.\\n\"\n                            \"Are the bill periods consecutive?\"\n                        )\n\n        # Check that all consumption values are above zero\n        if not any(\n            all(detail.Consumption &gt; 0 for detail in getattr(fuel, \"ConsumptionDetail\", []))\n            for _, fuel in all_fuels\n        ):\n            raise ValueError(\n                \"All Consumption values must be greater than zero for at least one fuel type.\"\n            )\n\n        # Check that no consumption is estimated (for now, fail if any are)\n        for _, fuel in all_fuels:\n            for detail in getattr(fuel, \"ConsumptionDetail\", []):\n                reading_type = getattr(detail, \"ReadingType\", None)\n                if reading_type and str(reading_type).lower() == \"estimate\":\n                    raise ValueError(\n                        f\"Estimated consumption value for {fuel.ConsumptionType.Energy.FuelType} cannot be greater than zero for bill-period: {detail.StartDateTime}\"\n                    )\n\n        # Check that each fuel type covers enough days and dates are valid\n        min_days = config[\"utility_bill_criteria\"][\"min_days_of_consumption_data\"]\n        recent_bill_max_age_days = config[\"utility_bill_criteria\"][\"max_days_since_newest_bill\"]\n\n        def _parse_dt(val):\n            return dt.strptime(str(val), \"%Y-%m-%dT%H:%M:%S\")\n\n        def _fuel_period_ok(fuel):\n            details = getattr(fuel, \"ConsumptionDetail\", [])\n            if details is None or len(details) == 0:\n                return False\n\n            first_start = _parse_dt(details[0].StartDateTime)\n            last_end = _parse_dt(details[-1].EndDateTime)\n\n            # Total covered span must meet min_days\n            if (last_end - first_start).days &lt; min_days:\n                logger.debug(\n                    f\"Found {(last_end - first_start).days} days of consumption data between {first_start} and {last_end}\"\n                )\n                return False\n\n            # Most recent bill must be within allowed age\n            if (now - last_end).days &gt; recent_bill_max_age_days:\n                logger.debug(\n                    f\"Found {(now - last_end).days} days since most recent bill, {last_end}\"\n                )\n                return False\n\n            # No future dates\n            for bill_info in details:\n                if (\n                    _parse_dt(bill_info.StartDateTime) &gt; now\n                    or _parse_dt(bill_info.EndDateTime) &gt; now\n                ):\n                    logger.debug(\n                        f\"Found future date in bill info: {bill_info.StartDateTime} - {bill_info.EndDateTime}\"\n                    )\n                    return False\n            return True\n\n        # Build mapping of fuel type -&gt; list of fuel entries\n        fuels_by_type: dict[str, list] = {}\n        for _, fuel in all_fuels:\n            if hasattr(fuel.ConsumptionType, \"Energy\"):\n                ftype = getattr(fuel.ConsumptionType.Energy, \"FuelType\", None)\n                if ftype is not None:\n                    fuels_by_type.setdefault(ftype, []).append(fuel)\n\n        for fuel_type, consumption_info in fuels_by_type.items():\n            # Require at least one consumption section for this fuel type to satisfy criteria\n            if not any(_fuel_period_ok(fuel) for fuel in consumption_info):\n                raise ValueError(\n                    f\"Consumption dates for {fuel_type} must cover at least {min_days} days and the most recent bill must end within the past {recent_bill_max_age_days} days.\"\n                )\n\n        # Check that electricity bill periods are within configured min/max days\n        longest_bill_period = config[\"utility_bill_criteria\"][\"max_electrical_bill_days\"]\n        shortest_bill_period = config[\"utility_bill_criteria\"][\"min_electrical_bill_days\"]\n        for _, fuel in all_fuels:\n            if getattr(fuel.ConsumptionType.Energy, \"FuelType\", None) == FuelType.ELECTRICITY.value:\n                for detail in getattr(fuel, \"ConsumptionDetail\", []):\n                    start_date = dt.strptime(str(detail.StartDateTime), \"%Y-%m-%dT%H:%M:%S\")\n                    end_date = dt.strptime(str(detail.EndDateTime), \"%Y-%m-%dT%H:%M:%S\")\n                    period_days = (end_date - start_date).days\n                    if period_days &gt; longest_bill_period:\n                        raise ValueError(\n                            f\"Electricity consumption bill period {start_date} - {end_date} cannot be longer than {longest_bill_period} days.\"\n                        )\n                    if period_days &lt; shortest_bill_period:\n                        raise ValueError(\n                            f\"Electricity consumption bill period {start_date} - {end_date} cannot be shorter than {shortest_bill_period} days.\"\n                        )\n\n        # Check that consumed fuel matches equipment fuel type (at least one section must match)\n        def fuel_type_in_any(fuel_type):\n            return any(\n                getattr(fuel.ConsumptionType.Energy, \"FuelType\", None) == fuel_type\n                for _, fuel in all_fuels\n            )\n\n        fuel_types = self.get_fuel_types()\n\n        for component, fuels in fuel_types.items():\n            for fuel in fuels:\n                if not fuel_type_in_any(fuel):\n                    raise ValueError(\n                        f\"HPXML consumption data missing for {component} fuel type ({fuel}).\"\n                    )\n</code></pre>"},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc.__init__","title":"<code>__init__(filename, validate_schema=True, validate_schematron=True)</code>","text":"<p>Create an HpxmlDoc object</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>PathLike</code> <p>Path to file to parse</p> required <code>validate_schema</code> <code>bool</code> <p>Validate against the HPXML schema, defaults to True</p> <code>True</code> <code>validate_schematron</code> <code>bool</code> <p>Validate against EPvalidator schematron, defaults to True</p> <code>True</code> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>def __init__(\n    self, filename: os.PathLike, validate_schema: bool = True, validate_schematron: bool = True\n):\n    \"\"\"Create an HpxmlDoc object\n\n    :param filename: Path to file to parse\n    :type filename: os.PathLike\n    :param validate_schema: Validate against the HPXML schema, defaults to True\n    :type validate_schema: bool, optional\n    :param validate_schematron: Validate against EPvalidator schematron, defaults to True\n    :type validate_schematron: bool, optional\n    \"\"\"\n    self.file_path = Path(filename).resolve()\n    self.tree = objectify.parse(str(filename))\n    self.root = self.tree.getroot()\n    self.ns = {\"h\": self.root.nsmap.get(\"h\", self.root.nsmap.get(None))}\n\n    if validate_schema:\n        hpxml_schema_filename = (\n            OS_HPXML_PATH / \"HPXMLtoOpenStudio\" / \"resources\" / \"hpxml_schema\" / \"HPXML.xsd\"\n        )\n        schema_doc = etree.parse(str(hpxml_schema_filename))\n        schema = etree.XMLSchema(schema_doc)\n        schema.assertValid(self.tree)\n\n    if validate_schematron:\n        hpxml_schematron_filename = (\n            OS_HPXML_PATH\n            / \"HPXMLtoOpenStudio\"\n            / \"resources\"\n            / \"hpxml_schematron\"\n            / \"EPvalidator.sch\"\n        )\n        schematron_doc = etree.parse(str(hpxml_schematron_filename))\n        schematron = isoschematron.Schematron(schematron_doc)\n        schematron.assertValid(self.tree)\n</code></pre>"},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc.get_building","title":"<code>get_building(building_id=None)</code>","text":"<p>Get a building element</p> <p>Parameters:</p> Name Type Description Default <code>building_id</code> <code>str | None</code> <p>The id of the Building to retrieve, gets first one if missing</p> <code>None</code> <p>Returns:</p> Type Description <code>objectify.ObjectifiedElement</code> <p>Building element</p> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>def get_building(self, building_id: str | None = None) -&gt; objectify.ObjectifiedElement:\n    \"\"\"Get a building element\n\n    :param building_id: The id of the Building to retrieve, gets first one if missing\n    :type building_id: str | None, optional\n    :return: Building element\n    :rtype: objectify.ObjectifiedElement\n    \"\"\"\n    if building_id is None:\n        return self.xpath(\"h:Building[1]\")[0]\n    else:\n        return self.xpath(\"h:Building[h:BuildingID/@id=$building_id]\", building_id=building_id)[\n            0\n        ]\n</code></pre>"},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc.get_consumptions","title":"<code>get_consumptions(building_id=None)</code>","text":"<p>Get all Consumption elements for a building</p> <p>Parameters:</p> Name Type Description Default <code>building_id</code> <code>str | None</code> <p>The id of the Building to retrieve, gets first one if missing</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of Consumption elements</p> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>def get_consumptions(\n    self, building_id: str | None = None\n) -&gt; tuple[objectify.ObjectifiedElement, ...]:\n    \"\"\"Get all Consumption elements for a building\n\n    :param building_id: The id of the Building to retrieve, gets first one if missing\n    :type building_id: str | None, optional\n    :return: Tuple of Consumption elements\n    :rtype: tuple\n    \"\"\"\n    if building_id is None:\n        return tuple(self.xpath(\"h:Consumption\"))\n    return tuple(\n        self.xpath(\"h:Consumption[h:BuildingID/@idref=$building_id]\", building_id=building_id)\n    )\n</code></pre>"},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc.get_epw_data","title":"<code>get_epw_data(building_id=None, **kw)</code>  <code>cached</code>","text":"<p>Get the epw data as a dataframe</p> <p>Parameters:</p> Name Type Description Default <code>building_id</code> <code>str | None</code> <p>The id of the Building to retrieve, gets first one if missing</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[pd.DataFrame, dict]</code> <p>Dataframe of epw and a dict of epw metadata</p> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>@functools.cache\ndef get_epw_data(self, building_id: str | None = None, **kw) -&gt; tuple[pd.DataFrame, dict]:\n    \"\"\"Get the epw data as a dataframe\n\n    :param building_id: The id of the Building to retrieve, gets first one if missing\n    :type building_id: str | None, optional\n    :return: Dataframe of epw and a dict of epw metadata\n    :rtype: tuple[pd.DataFrame, dict]\n    \"\"\"\n    return read_epw(self.get_epw_path(building_id), **kw)\n</code></pre>"},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc.get_epw_path","title":"<code>get_epw_path(building_id=None)</code>  <code>cached</code>","text":"<p>Get the filesystem path to the EPW file.</p> <p>Uses the same logic as OpenStudio-HPXML</p> <p>Parameters:</p> Name Type Description Default <code>building_id</code> <code>str | None</code> <p>The id of the Building to retrieve, gets first one if missing</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>path to epw file</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>Raises this error if the epw file doesn't exist</p> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>@functools.cache\ndef get_epw_path(self, building_id: str | None = None) -&gt; Path:\n    \"\"\"Get the filesystem path to the EPW file.\n\n    Uses the same logic as OpenStudio-HPXML\n\n    :param building_id: The id of the Building to retrieve, gets first one if missing\n    :type building_id: str | None, optional\n    :raises FileNotFoundError: Raises this error if the epw file doesn't exist\n    :return: path to epw file\n    :rtype: Path\n    \"\"\"\n    building = self.get_building(building_id)\n    try:\n        epw_file = str(\n            building.BuildingDetails.ClimateandRiskZones.WeatherStation.extension.EPWFilePath\n        )\n    except AttributeError:\n        zipcode = str(building.Site.Address.ZipCode).zfill(5)\n        zipcode_lookup_filename = (\n            OS_HPXML_PATH / \"HPXMLtoOpenStudio/resources/data/zipcode_weather_stations.csv\"\n        )\n        zipcodes = pd.read_csv(\n            zipcode_lookup_filename,\n            usecols=[\"zipcode\", \"station_filename\"],\n            index_col=\"zipcode\",\n            dtype={\"zipcode\": str},\n        )\n        epw_file = zipcodes.loc[zipcode, \"station_filename\"]\n\n    epw_path = Path(epw_file)\n    if not epw_path.is_absolute():\n        possible_parent_paths = [self.file_path.parent, OS_HPXML_PATH / \"weather\"]\n        for parent_path in possible_parent_paths:\n            epw_path = parent_path / Path(epw_file)\n            if epw_path.exists():\n                break\n    if not epw_path.exists():\n        raise FileNotFoundError(str(epw_path))\n\n    return epw_path\n</code></pre>"},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc.get_first_building_id","title":"<code>get_first_building_id()</code>","text":"<p>Get the id of the first Building element in the file.</p> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>def get_first_building_id(self) -&gt; str:\n    \"\"\"Get the id of the first Building element in the file.\"\"\"\n    return self.xpath(\"h:Building[1]/h:BuildingID/@id\", smart_strings=False)[0]\n</code></pre>"},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc.get_fuel_types","title":"<code>get_fuel_types(building_id=None)</code>","text":"<p>Get fuel types providing heating, cooling, water heating, clothes drying, and cooking</p> <p>Parameters:</p> Name Type Description Default <code>building_id</code> <code>str | None</code> <p>The id of the Building to retrieve, gets first one if missing</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[str, set[str]]</code> <p>fuel types for heating, cooling, water heaters, clothes dryers, and cooking</p> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>def get_fuel_types(self, building_id: str | None = None) -&gt; tuple[str, set[str]]:\n    \"\"\"Get fuel types providing heating, cooling, water heating, clothes drying, and cooking\n\n    :param building_id: The id of the Building to retrieve, gets first one if missing\n    :type building_id: str\n    :return: fuel types for heating, cooling, water heaters, clothes dryers, and cooking\n    :rtype: tuple[str, set[str]]\n    \"\"\"\n\n    building = self.get_building(building_id)\n    fuel_types = {\n        \"heating\": set(),\n        \"cooling\": set(),\n        \"water heater\": set(),\n        \"clothes dryer\": set(),\n        \"cooking\": set(),\n    }\n    if (\n        hasattr(building.BuildingDetails, \"Systems\")\n        and hasattr(building.BuildingDetails.Systems, \"HVAC\")\n        and hasattr(building.BuildingDetails.Systems.HVAC, \"HVACPlant\")\n    ):\n        for hvac_system in building.BuildingDetails.Systems.HVAC.HVACPlant:\n            if hasattr(hvac_system, \"HeatingSystem\") and hasattr(\n                hvac_system.HeatingSystem, \"HeatingSystemFuel\"\n            ):\n                fuel_types[\"heating\"].add(\n                    hvac_system.HeatingSystem.HeatingSystemFuel.text.strip()\n                )\n\n            if hasattr(hvac_system, \"CoolingSystem\"):\n                if hasattr(hvac_system.CoolingSystem, \"CoolingSystemFuel\"):\n                    fuel_types[\"cooling\"].add(\n                        hvac_system.CoolingSystem.CoolingSystemFuel.text.strip()\n                    )\n                if hasattr(hvac_system.CoolingSystem, \"IntegratedHeatingSystemFuel\"):\n                    fuel_types[\"heating\"].add(\n                        hvac_system.CoolingSystem.IntegratedHeatingSystemFuel.text.strip()\n                    )\n\n            if hasattr(hvac_system, \"HeatPump\"):\n                if hasattr(hvac_system.HeatPump, \"HeatPumpFuel\"):\n                    fuel_types[\"heating\"].add(hvac_system.HeatPump.HeatPumpFuel.text.strip())\n                    fuel_types[\"cooling\"].add(hvac_system.HeatPump.HeatPumpFuel.text.strip())\n                if hasattr(hvac_system.HeatPump, \"BackupSystemFuel\"):\n                    fuel_types[\"heating\"].add(\n                        hvac_system.HeatPump.BackupSystemFuel.text.strip()\n                    )\n\n    if (\n        hasattr(building.BuildingDetails, \"Systems\")\n        and hasattr(building.BuildingDetails.Systems, \"WaterHeating\")\n        and hasattr(building.BuildingDetails.Systems.WaterHeating, \"WaterHeatingSystem\")\n    ):\n        for water_heater in building.BuildingDetails.Systems.WaterHeating.WaterHeatingSystem:\n            if hasattr(water_heater, \"FuelType\"):\n                fuel_types[\"water heater\"].add(water_heater.FuelType.text.strip())\n            elif hasattr(water_heater, \"RelatedHVACSystem\"):\n                # No need to retrieve, we already have the fuel type for the heating system\n                pass\n\n    if hasattr(building.BuildingDetails, \"Appliances\") and hasattr(\n        building.BuildingDetails.Appliances, \"ClothesDryer\"\n    ):\n        for clothes_dryer in building.BuildingDetails.Appliances.ClothesDryer:\n            if hasattr(clothes_dryer, \"FuelType\"):\n                fuel_types[\"clothes dryer\"].add(clothes_dryer.FuelType.text.strip())\n\n    if hasattr(building.BuildingDetails, \"Appliances\") and hasattr(\n        building.BuildingDetails.Appliances, \"CookingRange\"\n    ):\n        for cooking_range in building.BuildingDetails.Appliances.CookingRange:\n            if hasattr(cooking_range, \"FuelType\"):\n                fuel_types[\"cooking\"].add(cooking_range.FuelType.text.strip())\n\n    return fuel_types\n</code></pre>"},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc.get_lat_lon","title":"<code>get_lat_lon(building_id=None)</code>","text":"<p>Get latitude, longitude from hpxml file</p> <p>Parameters:</p> Name Type Description Default <code>building_id</code> <code>str | None</code> <p>Optional building_id of the building you want to get location for.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Latitude and longitude</p> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>def get_lat_lon(self, building_id: str | None = None) -&gt; tuple[float, float]:\n    \"\"\"Get latitude, longitude from hpxml file\n\n    :param building_id: Optional building_id of the building you want to get location for.\n    :type building_id: str | None\n    :return: Latitude and longitude\n    :rtype: tuple[float, float]\n    \"\"\"\n    building = self.get_building(building_id)\n    try:\n        # Option 1: Get directly from HPXML\n        geolocation = building.Site.GeoLocation\n        lat = float(geolocation.Latitude)\n        lon = float(geolocation.Longitude)\n    except AttributeError:\n        _, epw_metadata = self.get_epw_data(building_id)\n        lat = epw_metadata[\"latitude\"]\n        lon = epw_metadata[\"longitude\"]\n\n    return lat, lon\n</code></pre>"},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc.hpxml_data_error_checking","title":"<code>hpxml_data_error_checking(config)</code>","text":"<p>Check for common HPXML errors</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>Configuration dictionary, combination of default and user config</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error is found</p> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>def hpxml_data_error_checking(self, config: dict) -&gt; None:\n    \"\"\"Check for common HPXML errors\n\n    :param config: Configuration dictionary, combination of default and user config\n    :type config: dict\n\n    :raises ValueError: If an error is found\n    \"\"\"\n    now = dt.now()\n    building = self.get_building()\n    consumptions = self.get_consumptions()\n\n    # Check that the building doesn't have PV\n    try:\n        building.BuildingDetails.Systems.Photovoltaics\n        raise ValueError(\"PV is not supported with automated calibration at this time.\")\n    except AttributeError:\n        pass\n\n    # Helper: flatten all fuel entries across all consumption elements\n    all_fuels = [\n        (consumption_elem, fuel)\n        for consumption_elem in consumptions\n        for fuel in consumption_elem.ConsumptionDetails.ConsumptionInfo\n    ]\n\n    # Check that every fuel in every consumption element has a ConsumptionType.Energy element\n    if not all(\n        all(\n            hasattr(fuel.ConsumptionType, \"Energy\")\n            for fuel in consumption_elem.ConsumptionDetails.ConsumptionInfo\n        )\n        for consumption_elem in consumptions\n    ):\n        raise ValueError(\n            \"Every fuel in every Consumption section must have a valid ConsumptionType.Energy element.\"\n        )\n\n    # Check that at least one consumption element matches the building ID\n    if not any(\n        consumption_elem.BuildingID.attrib[\"idref\"] == building.BuildingID.attrib[\"id\"]\n        for consumption_elem in consumptions\n    ):\n        raise ValueError(\"No Consumption section matches the Building ID in the HPXML file.\")\n\n    # Check that at least one fuel per fuel type has valid units\n    def valid_unit(fuel):\n        fuel_type = fuel.ConsumptionType.Energy.FuelType\n        unit = fuel.ConsumptionType.Energy.UnitofMeasure\n        match fuel_type:\n            case FuelType.ELECTRICITY.value:\n                return unit in (\"kWh\", \"MWh\")\n            case FuelType.NATURAL_GAS.value:\n                return unit in (\"therms\", \"Btu\", \"kBtu\", \"MBtu\", \"ccf\", \"kcf\", \"Mcf\")\n            case FuelType.FUEL_OIL.value | FuelType.PROPANE.value:\n                return unit in (\"gal\", \"Btu\", \"kBtu\", \"MBtu\", \"therms\")\n            case _:\n                return False\n\n    for fuel_type in {\n        getattr(fuel.ConsumptionType.Energy, \"FuelType\", None)\n        for _, fuel in all_fuels\n        if hasattr(fuel.ConsumptionType, \"Energy\")\n    }:\n        if fuel_type is None:\n            continue\n        if not any(\n            getattr(fuel.ConsumptionType.Energy, \"FuelType\", None) == fuel_type\n            and valid_unit(fuel)\n            for _, fuel in all_fuels\n        ):\n            raise ValueError(\n                f\"No valid unit found for fuel type '{fuel_type}' in any Consumption section.\"\n            )\n\n    # Check that for each fuel type, there is only one Consumption section\n    fuel_type_to_consumption = {}\n    for consumption_elem in consumptions:\n        for fuel in consumption_elem.ConsumptionDetails.ConsumptionInfo:\n            fuel_type = getattr(fuel.ConsumptionType.Energy, \"FuelType\", None)\n            if fuel_type is None:\n                continue\n            if fuel_type in fuel_type_to_consumption:\n                raise ValueError(\n                    f\"Multiple Consumption sections found for fuel type '{fuel_type}'. \"\n                    \"Only one section per fuel type is allowed.\"\n                )\n            fuel_type_to_consumption[fuel_type] = consumption_elem\n\n    # Check that electricity consumption is present in at least one section\n    if not any(\n        getattr(fuel.ConsumptionType.Energy, \"FuelType\", None) == FuelType.ELECTRICITY.value\n        for _, fuel in all_fuels\n    ):\n        raise ValueError(\n            \"Electricity consumption is required for calibration. \"\n            \"Please provide electricity consumption data in the HPXML file.\"\n        )\n\n    # Check that for each fuel, all periods are consecutive, non-overlapping, and valid\n    for _, fuel in all_fuels:\n        details = getattr(fuel, \"ConsumptionDetail\", [])\n        for i, detail in enumerate(details):\n            try:\n                start_date = dt.strptime(str(detail.StartDateTime), \"%Y-%m-%dT%H:%M:%S\")\n            except AttributeError:\n                raise ValueError(\n                    f\"Consumption detail {i} for {fuel.ConsumptionType.Energy.FuelType} is missing StartDateTime.\"\n                )\n            try:\n                end_date = dt.strptime(str(detail.EndDateTime), \"%Y-%m-%dT%H:%M:%S\")\n            except AttributeError:\n                raise ValueError(\n                    f\"Consumption detail {i} for {fuel.ConsumptionType.Energy.FuelType} is missing EndDateTime.\"\n                )\n            if i &gt; 0:\n                prev_detail = details[i - 1]\n                prev_end = dt.strptime(str(prev_detail.EndDateTime), \"%Y-%m-%dT%H:%M:%S\")\n                curr_start = dt.strptime(str(detail.StartDateTime), \"%Y-%m-%dT%H:%M:%S\")\n                if curr_start &lt; prev_end:\n                    raise ValueError(\n                        f\"Consumption details for {fuel.ConsumptionType.Energy.FuelType} overlap: \"\n                        f\"{prev_detail.StartDateTime} - {prev_detail.EndDateTime} overlaps with \"\n                        f\"{detail.StartDateTime} - {detail.EndDateTime}\"\n                    )\n                if (curr_start - prev_end) &gt; timedelta(minutes=1):\n                    raise ValueError(\n                        f\"Gap in consumption data for {fuel.ConsumptionType.Energy.FuelType}: \"\n                        f\"Period between {prev_detail.EndDateTime} and {detail.StartDateTime} is not covered.\\n\"\n                        \"Are the bill periods consecutive?\"\n                    )\n\n    # Check that all consumption values are above zero\n    if not any(\n        all(detail.Consumption &gt; 0 for detail in getattr(fuel, \"ConsumptionDetail\", []))\n        for _, fuel in all_fuels\n    ):\n        raise ValueError(\n            \"All Consumption values must be greater than zero for at least one fuel type.\"\n        )\n\n    # Check that no consumption is estimated (for now, fail if any are)\n    for _, fuel in all_fuels:\n        for detail in getattr(fuel, \"ConsumptionDetail\", []):\n            reading_type = getattr(detail, \"ReadingType\", None)\n            if reading_type and str(reading_type).lower() == \"estimate\":\n                raise ValueError(\n                    f\"Estimated consumption value for {fuel.ConsumptionType.Energy.FuelType} cannot be greater than zero for bill-period: {detail.StartDateTime}\"\n                )\n\n    # Check that each fuel type covers enough days and dates are valid\n    min_days = config[\"utility_bill_criteria\"][\"min_days_of_consumption_data\"]\n    recent_bill_max_age_days = config[\"utility_bill_criteria\"][\"max_days_since_newest_bill\"]\n\n    def _parse_dt(val):\n        return dt.strptime(str(val), \"%Y-%m-%dT%H:%M:%S\")\n\n    def _fuel_period_ok(fuel):\n        details = getattr(fuel, \"ConsumptionDetail\", [])\n        if details is None or len(details) == 0:\n            return False\n\n        first_start = _parse_dt(details[0].StartDateTime)\n        last_end = _parse_dt(details[-1].EndDateTime)\n\n        # Total covered span must meet min_days\n        if (last_end - first_start).days &lt; min_days:\n            logger.debug(\n                f\"Found {(last_end - first_start).days} days of consumption data between {first_start} and {last_end}\"\n            )\n            return False\n\n        # Most recent bill must be within allowed age\n        if (now - last_end).days &gt; recent_bill_max_age_days:\n            logger.debug(\n                f\"Found {(now - last_end).days} days since most recent bill, {last_end}\"\n            )\n            return False\n\n        # No future dates\n        for bill_info in details:\n            if (\n                _parse_dt(bill_info.StartDateTime) &gt; now\n                or _parse_dt(bill_info.EndDateTime) &gt; now\n            ):\n                logger.debug(\n                    f\"Found future date in bill info: {bill_info.StartDateTime} - {bill_info.EndDateTime}\"\n                )\n                return False\n        return True\n\n    # Build mapping of fuel type -&gt; list of fuel entries\n    fuels_by_type: dict[str, list] = {}\n    for _, fuel in all_fuels:\n        if hasattr(fuel.ConsumptionType, \"Energy\"):\n            ftype = getattr(fuel.ConsumptionType.Energy, \"FuelType\", None)\n            if ftype is not None:\n                fuels_by_type.setdefault(ftype, []).append(fuel)\n\n    for fuel_type, consumption_info in fuels_by_type.items():\n        # Require at least one consumption section for this fuel type to satisfy criteria\n        if not any(_fuel_period_ok(fuel) for fuel in consumption_info):\n            raise ValueError(\n                f\"Consumption dates for {fuel_type} must cover at least {min_days} days and the most recent bill must end within the past {recent_bill_max_age_days} days.\"\n            )\n\n    # Check that electricity bill periods are within configured min/max days\n    longest_bill_period = config[\"utility_bill_criteria\"][\"max_electrical_bill_days\"]\n    shortest_bill_period = config[\"utility_bill_criteria\"][\"min_electrical_bill_days\"]\n    for _, fuel in all_fuels:\n        if getattr(fuel.ConsumptionType.Energy, \"FuelType\", None) == FuelType.ELECTRICITY.value:\n            for detail in getattr(fuel, \"ConsumptionDetail\", []):\n                start_date = dt.strptime(str(detail.StartDateTime), \"%Y-%m-%dT%H:%M:%S\")\n                end_date = dt.strptime(str(detail.EndDateTime), \"%Y-%m-%dT%H:%M:%S\")\n                period_days = (end_date - start_date).days\n                if period_days &gt; longest_bill_period:\n                    raise ValueError(\n                        f\"Electricity consumption bill period {start_date} - {end_date} cannot be longer than {longest_bill_period} days.\"\n                    )\n                if period_days &lt; shortest_bill_period:\n                    raise ValueError(\n                        f\"Electricity consumption bill period {start_date} - {end_date} cannot be shorter than {shortest_bill_period} days.\"\n                    )\n\n    # Check that consumed fuel matches equipment fuel type (at least one section must match)\n    def fuel_type_in_any(fuel_type):\n        return any(\n            getattr(fuel.ConsumptionType.Energy, \"FuelType\", None) == fuel_type\n            for _, fuel in all_fuels\n        )\n\n    fuel_types = self.get_fuel_types()\n\n    for component, fuels in fuel_types.items():\n        for fuel in fuels:\n            if not fuel_type_in_any(fuel):\n                raise ValueError(\n                    f\"HPXML consumption data missing for {component} fuel type ({fuel}).\"\n                )\n</code></pre>"},{"location":"code_documentation/hpxml/#src.openstudio_hpxml_calibration.hpxml.HpxmlDoc.xpath","title":"<code>xpath(xpath_expr, el=None, **kw)</code>","text":"<p>Run an xpath query on the file</p> <p>The h: namespace is the default HPXML namespace. No namespaces need to be passed into the function.</p> <p><code>hpxml.xpath(\"//h:Wall\")</code></p> <p>Parameters:</p> Name Type Description Default <code>xpath_expr</code> <code>str</code> <p>Xpath expression to evaluate</p> required <code>el</code> <code>ObjectifiedElement | None</code> <p>Optional element from which to evaluate the xpath, if omitted will use the root HPXML element.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[objectify.ObjectifiedElement]</code> <p>A list of elements that match the xpath expression.</p> Source code in <code>src/openstudio_hpxml_calibration/hpxml.py</code> <pre><code>def xpath(\n    self, xpath_expr: str, el: objectify.ObjectifiedElement | None = None, **kw\n) -&gt; list[objectify.ObjectifiedElement]:\n    \"\"\"Run an xpath query on the file\n\n    The h: namespace is the default HPXML namespace. No namespaces need to\n    be passed into the function.\n\n    ``hpxml.xpath(\"//h:Wall\")``\n\n    :param xpath_expr: Xpath expression to evaluate\n    :type xpath_expr: str\n    :param el: Optional element from which to evaluate the xpath, if omitted\n        will use the root HPXML element.\n    :type el: objectify.ObjectifiedElement | None, optional\n    :return: A list of elements that match the xpath expression.\n    :rtype: list[objectify.ObjectifiedElement]\n    \"\"\"\n    if el is None:\n        el = self.root\n    ns = re.match(r\"\\{(.+)\\}\", el.tag).group(1)\n    return el.xpath(xpath_expr, namespaces={\"h\": ns}, **kw)\n</code></pre>"},{"location":"code_documentation/weather_normalization/degree_days/","title":"Degree Days","text":""},{"location":"code_documentation/weather_normalization/degree_days/#src.openstudio_hpxml_calibration.weather_normalization.degree_days.calc_daily_dbs","title":"<code>calc_daily_dbs(hpxml)</code>","text":"<p>Calculate daily average dry bulb temperatures from EPW weather data.</p> <p>This function computes daily average dry bulb temperatures in both Celsius and Fahrenheit from the EPW weather data contained in the provided HPXML document.</p> <p>Parameters:</p> Name Type Description Default <code>hpxml</code> <code>HpxmlDoc</code> <p>HPXML document object containing weather data.</p> required <p>Returns:</p> Type Description <code>namedtuple</code> <p>Named tuple with fields 'c' (Celsius) and 'f' (Fahrenheit), each as a pandas Series.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/degree_days.py</code> <pre><code>def calc_daily_dbs(hpxml: HpxmlDoc) -&gt; namedtuple:\n    \"\"\"\n    Calculate daily average dry bulb temperatures from EPW weather data.\n\n    This function computes daily average dry bulb temperatures in both Celsius and Fahrenheit\n    from the EPW weather data contained in the provided HPXML document.\n\n    :param hpxml: HPXML document object containing weather data.\n    :type hpxml: HpxmlDoc\n    :return: Named tuple with fields 'c' (Celsius) and 'f' (Fahrenheit), each as a pandas Series.\n    :rtype: namedtuple\n    \"\"\"\n    DailyTemps = namedtuple(\"DailyTemps\", [\"c\", \"f\"])\n    epw, _ = hpxml.get_epw_data(coerce_year=2007)\n    epw_daily_avg_temp_c = epw[\"temp_air\"].groupby(pd.Grouper(freq=\"D\")).mean()\n    epw_daily_avg_temp_f = convert_units(epw_daily_avg_temp_c, \"c\", \"f\")\n    return DailyTemps(c=epw_daily_avg_temp_c, f=epw_daily_avg_temp_f)\n</code></pre>"},{"location":"code_documentation/weather_normalization/degree_days/#src.openstudio_hpxml_calibration.weather_normalization.degree_days.calc_degree_days","title":"<code>calc_degree_days(daily_dbs, base_temp_f, is_heating)</code>","text":"<p>Calculate degree days from daily temperature data.</p> <p>This function computes the total heating or cooling degree days for a given base temperature using daily average dry bulb temperatures.</p> <p>Parameters:</p> Name Type Description Default <code>daily_dbs</code> <code>Series</code> <p>Series of daily average dry bulb temperatures (\u00b0F).</p> required <code>base_temp_f</code> <code>float</code> <p>Base temperature in Fahrenheit for degree day calculation.</p> required <code>is_heating</code> <code>bool</code> <p>If True, calculates heating degree days; if False, cooling degree days.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total degree days for the specified base temperature and mode.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/degree_days.py</code> <pre><code>def calc_degree_days(daily_dbs: pd.Series, base_temp_f: float, is_heating: bool) -&gt; float:\n    \"\"\"\n    Calculate degree days from daily temperature data.\n\n    This function computes the total heating or cooling degree days for a given base temperature\n    using daily average dry bulb temperatures.\n\n    :param daily_dbs: Series of daily average dry bulb temperatures (\u00b0F).\n    :type daily_dbs: pd.Series\n    :param base_temp_f: Base temperature in Fahrenheit for degree day calculation.\n    :type base_temp_f: float\n    :param is_heating: If True, calculates heating degree days; if False, cooling degree days.\n    :type is_heating: bool\n    :return: Total degree days for the specified base temperature and mode.\n    :rtype: float\n    \"\"\"\n\n    deg_days = []\n    for temp in daily_dbs:\n        if is_heating and temp &lt; base_temp_f:\n            deg_days.append(base_temp_f - temp)\n        elif not is_heating and temp &gt; base_temp_f:\n            deg_days.append(temp - base_temp_f)\n\n    if len(deg_days) == 0:\n        return 0.0\n\n    deg_days_sum = round(sum(deg_days), 2)\n    return deg_days_sum\n</code></pre>"},{"location":"code_documentation/weather_normalization/degree_days/#src.openstudio_hpxml_calibration.weather_normalization.degree_days.calc_heat_cool_degree_days","title":"<code>calc_heat_cool_degree_days(dailydbs)</code>","text":"<p>Calculate heating and cooling degree days from daily temperature data.</p> <p>This function returns a dictionary containing heating and cooling degree days (HDD65F, CDD65F) for the provided daily average dry bulb temperatures.</p> <p>Parameters:</p> Name Type Description Default <code>dailydbs</code> <code>Series</code> <p>Series of daily average dry bulb temperatures (\u00b0F).</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with keys 'HDD65F' and 'CDD65F' and their respective degree day values.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/degree_days.py</code> <pre><code>def calc_heat_cool_degree_days(dailydbs: pd.Series) -&gt; dict:\n    \"\"\"\n    Calculate heating and cooling degree days from daily temperature data.\n\n    This function returns a dictionary containing heating and cooling degree days (HDD65F, CDD65F)\n    for the provided daily average dry bulb temperatures.\n\n    :param dailydbs: Series of daily average dry bulb temperatures (\u00b0F).\n    :type dailydbs: pd.Series\n    :return: Dictionary with keys 'HDD65F' and 'CDD65F' and their respective degree day values.\n    :rtype: dict\n    \"\"\"\n    degree_days = {}\n    degree_days[\"HDD65F\"] = calc_degree_days(dailydbs, 65, True)\n    # degree_days[\"HDD50F\"] = calc_degree_days(dailydbs, 50, True)\n    degree_days[\"CDD65F\"] = calc_degree_days(dailydbs, 65, False)\n    # degree_days[\"CDD50F\"] = calc_degree_days(dailydbs, 50, False)\n    return degree_days\n</code></pre>"},{"location":"code_documentation/weather_normalization/degree_days/#src.openstudio_hpxml_calibration.weather_normalization.degree_days.calculate_annual_degree_days","title":"<code>calculate_annual_degree_days(hpxml)</code>","text":"<p>Calculate annual heating and cooling degree days for each fuel type.</p> <p>This function computes the total heating degree days (HDD) and cooling degree days (CDD) for the actual period and the TMY period, for each fuel type present in the HPXML document.</p> <p>Parameters:</p> Name Type Description Default <code>hpxml</code> <code>HpxmlDoc</code> <p>HPXML document object containing weather and fuel information.</p> required <p>Returns:</p> Type Description <code>tuple[dict, dict]</code> <p>Tuple containing dictionaries of total period TMY degree days and actual degree days by fuel type.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/degree_days.py</code> <pre><code>def calculate_annual_degree_days(hpxml: HpxmlDoc) -&gt; tuple[dict, dict]:\n    \"\"\"\n    Calculate annual heating and cooling degree days for each fuel type.\n\n    This function computes the total heating degree days (HDD) and cooling degree days (CDD)\n    for the actual period and the TMY period, for each fuel type present in the HPXML document.\n\n    :param hpxml: HPXML document object containing weather and fuel information.\n    :type hpxml: HpxmlDoc\n    :return: Tuple containing dictionaries of total period TMY degree days and actual degree days by fuel type.\n    :rtype: tuple[dict, dict]\n    \"\"\"\n    tmy_dry_bulb_temps_f = calc_daily_dbs(hpxml).f\n    bills_by_fuel_type, _, _ = ud.get_bills_from_hpxml(hpxml)\n    lat, lon = hpxml.get_lat_lon()\n    bill_tmy_degree_days = {}\n    total_period_actual_dd = {}\n\n    # Use day-of-year because TMY data contains multiple years\n    tmy_temp_index_doy = tmy_dry_bulb_temps_f.index.dayofyear\n\n    for fuel_type, bills in bills_by_fuel_type.items():\n        # format fuel type for dictionary keys\n        fuel_type_name = fuel_type.name.lower().replace(\"_\", \" \")\n        # Get degree days of actual weather during bill periods\n        _, actual_temp_f = ud.join_bills_weather(bills, lat, lon)\n        daily_actual_temps = actual_temp_f.resample(\"D\").mean()\n        actual_degree_days = calc_heat_cool_degree_days(daily_actual_temps)\n        actual_degree_days = {k: round(v) for k, v in actual_degree_days.items()}\n        total_period_actual_dd[fuel_type_name] = actual_degree_days\n\n        # Get degree days of TMY weather\n        bill_results = []\n        for _, row in bills.iterrows():\n            start_doy = row[\"start_day_of_year\"]\n            end_doy = row[\"end_day_of_year\"]\n\n            # Handle bills that wrap around the end of the year\n            if start_doy &lt;= end_doy:\n                mask = (tmy_temp_index_doy &gt;= start_doy) &amp; (tmy_temp_index_doy &lt;= end_doy)\n            else:\n                mask = (tmy_temp_index_doy &gt;= start_doy) | (tmy_temp_index_doy &lt;= end_doy)\n\n            # Select the dry bulb temperatures for the bill period\n            bill_dry_bulbs_tmy = tmy_dry_bulb_temps_f[mask]\n            tmy_degree_days = calc_heat_cool_degree_days(bill_dry_bulbs_tmy)\n            bill_results.append(\n                {\n                    \"start_date\": row[\"start_date\"],\n                    \"end_date\": row[\"end_date\"],\n                    **tmy_degree_days,\n                }\n            )\n        bill_tmy_degree_days[fuel_type_name] = bill_results\n\n    total_period_tmy_dd = {}\n    for fuel, bill_list in bill_tmy_degree_days.items():\n        hdd_total = round(sum(bill.get(\"HDD65F\", 0) for bill in bill_list))\n        cdd_total = round(sum(bill.get(\"CDD65F\", 0) for bill in bill_list))\n        total_period_tmy_dd[fuel] = {\"HDD65F\": hdd_total, \"CDD65F\": cdd_total}\n\n    return total_period_tmy_dd, total_period_actual_dd\n</code></pre>"},{"location":"code_documentation/weather_normalization/inverse_model/","title":"Inverse Model","text":""},{"location":"code_documentation/weather_normalization/inverse_model/#src.openstudio_hpxml_calibration.weather_normalization.inverse_model.InverseModel","title":"<code>InverseModel</code>","text":"Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/inverse_model.py</code> <pre><code>class InverseModel:\n    def __init__(self, hpxml: HpxmlDoc, user_config: dict, building_id: str | None = None):\n        \"\"\"\n        Initialize the InverseModel for weather normalization.\n\n        Sets up regression models and bill data for each fuel type based on the HPXML document.\n\n        :param hpxml: HPXML document object.\n        :type hpxml: HpxmlDoc\n        :param user_config: Optional user configuration dictionary.\n        :type user_config: dict, optional\n        \"\"\"\n        self.user_config = user_config\n        self.hpxml = hpxml\n        self.building_id = building_id\n        self.bills_by_fuel_type, self.bill_units, self.tz = ud.get_bills_from_hpxml(\n            hpxml, building_id\n        )\n        self.bills_weather_by_fuel_type_in_btu = {}\n        self.lat_lon = hpxml.get_lat_lon()\n        self.regression_models: dict[FuelType, UtilityBillRegressionModel] = {}\n        for fuel_type, bills in self.bills_by_fuel_type.items():\n            bills_weather, _ = ud.join_bills_weather(bills, *self.lat_lon)\n            for col in [\"consumption\", \"daily_consumption\"]:\n                bills_weather[col] = convert_hpxml_energy_units(\n                    bills_weather[col],\n                    self.bill_units[fuel_type],\n                    EnergyUnitType.BTU,\n                    fuel_type,\n                )\n            self.bills_weather_by_fuel_type_in_btu[fuel_type] = bills_weather\n\n    def get_model(self, fuel_type: FuelType) -&gt; UtilityBillRegressionModel:\n        \"\"\"\n        Retrieve or fit the regression model for a given fuel type.\n\n        This method returns the regression model for the specified fuel type, fitting it if necessary\n        using the bill and weather data from the HPXML document.\n\n        :param fuel_type: The fuel type for which to retrieve or fit the regression model.\n        :type fuel_type: FuelType\n        :return: The fitted regression model for the specified fuel type.\n        :rtype: UtilityBillRegressionModel\n        \"\"\"\n        try:\n            return self.regression_models[fuel_type]\n        except KeyError:\n            bills_weather = self.bills_weather_by_fuel_type_in_btu[fuel_type]\n            fuel_types = self.hpxml.get_fuel_types()\n            conditioning_fuels = fuel_types[\"heating\"] | fuel_types[\"cooling\"]\n            model = fit_model(\n                bills_weather,\n                cvrmse_requirement=self.user_config[\"acceptance_criteria\"][\n                    \"bill_regression_max_cvrmse\"\n                ],\n                conditioning_fuels=conditioning_fuels,\n                fuel_type=fuel_type,\n            )\n            self.regression_models[fuel_type] = model\n            return model\n\n    def predict_epw_daily(self, fuel_type: FuelType) -&gt; pd.Series:\n        \"\"\"\n        Predict daily energy consumption using the regression model for a given fuel type.\n\n        Uses the fitted regression model to estimate daily consumption for each day in the EPW weather file.\n\n        :param fuel_type: The fuel type for which to predict daily consumption.\n        :type fuel_type: FuelType\n        :return: Array of predicted daily consumption values.\n        :rtype: np.ndarray\n        \"\"\"\n        model = self.get_model(fuel_type)\n        epw, _ = self.hpxml.get_epw_data(coerce_year=2007)\n        epw_daily_avg_temp = epw[\"temp_air\"].groupby(pd.Grouper(freq=\"D\")).mean() * 1.8 + 32\n        daily_predicted_fuel_use = model.predict_disaggregated(epw_daily_avg_temp.to_numpy())\n        return daily_predicted_fuel_use\n</code></pre>"},{"location":"code_documentation/weather_normalization/inverse_model/#src.openstudio_hpxml_calibration.weather_normalization.inverse_model.InverseModel.__init__","title":"<code>__init__(hpxml, user_config, building_id=None)</code>","text":"<p>Initialize the InverseModel for weather normalization.</p> <p>Sets up regression models and bill data for each fuel type based on the HPXML document.</p> <p>Parameters:</p> Name Type Description Default <code>hpxml</code> <code>HpxmlDoc</code> <p>HPXML document object.</p> required <code>user_config</code> <code>dict</code> <p>Optional user configuration dictionary.</p> required Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/inverse_model.py</code> <pre><code>def __init__(self, hpxml: HpxmlDoc, user_config: dict, building_id: str | None = None):\n    \"\"\"\n    Initialize the InverseModel for weather normalization.\n\n    Sets up regression models and bill data for each fuel type based on the HPXML document.\n\n    :param hpxml: HPXML document object.\n    :type hpxml: HpxmlDoc\n    :param user_config: Optional user configuration dictionary.\n    :type user_config: dict, optional\n    \"\"\"\n    self.user_config = user_config\n    self.hpxml = hpxml\n    self.building_id = building_id\n    self.bills_by_fuel_type, self.bill_units, self.tz = ud.get_bills_from_hpxml(\n        hpxml, building_id\n    )\n    self.bills_weather_by_fuel_type_in_btu = {}\n    self.lat_lon = hpxml.get_lat_lon()\n    self.regression_models: dict[FuelType, UtilityBillRegressionModel] = {}\n    for fuel_type, bills in self.bills_by_fuel_type.items():\n        bills_weather, _ = ud.join_bills_weather(bills, *self.lat_lon)\n        for col in [\"consumption\", \"daily_consumption\"]:\n            bills_weather[col] = convert_hpxml_energy_units(\n                bills_weather[col],\n                self.bill_units[fuel_type],\n                EnergyUnitType.BTU,\n                fuel_type,\n            )\n        self.bills_weather_by_fuel_type_in_btu[fuel_type] = bills_weather\n</code></pre>"},{"location":"code_documentation/weather_normalization/inverse_model/#src.openstudio_hpxml_calibration.weather_normalization.inverse_model.InverseModel.get_model","title":"<code>get_model(fuel_type)</code>","text":"<p>Retrieve or fit the regression model for a given fuel type.</p> <p>This method returns the regression model for the specified fuel type, fitting it if necessary using the bill and weather data from the HPXML document.</p> <p>Parameters:</p> Name Type Description Default <code>fuel_type</code> <code>FuelType</code> <p>The fuel type for which to retrieve or fit the regression model.</p> required <p>Returns:</p> Type Description <code>UtilityBillRegressionModel</code> <p>The fitted regression model for the specified fuel type.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/inverse_model.py</code> <pre><code>def get_model(self, fuel_type: FuelType) -&gt; UtilityBillRegressionModel:\n    \"\"\"\n    Retrieve or fit the regression model for a given fuel type.\n\n    This method returns the regression model for the specified fuel type, fitting it if necessary\n    using the bill and weather data from the HPXML document.\n\n    :param fuel_type: The fuel type for which to retrieve or fit the regression model.\n    :type fuel_type: FuelType\n    :return: The fitted regression model for the specified fuel type.\n    :rtype: UtilityBillRegressionModel\n    \"\"\"\n    try:\n        return self.regression_models[fuel_type]\n    except KeyError:\n        bills_weather = self.bills_weather_by_fuel_type_in_btu[fuel_type]\n        fuel_types = self.hpxml.get_fuel_types()\n        conditioning_fuels = fuel_types[\"heating\"] | fuel_types[\"cooling\"]\n        model = fit_model(\n            bills_weather,\n            cvrmse_requirement=self.user_config[\"acceptance_criteria\"][\n                \"bill_regression_max_cvrmse\"\n            ],\n            conditioning_fuels=conditioning_fuels,\n            fuel_type=fuel_type,\n        )\n        self.regression_models[fuel_type] = model\n        return model\n</code></pre>"},{"location":"code_documentation/weather_normalization/inverse_model/#src.openstudio_hpxml_calibration.weather_normalization.inverse_model.InverseModel.predict_epw_daily","title":"<code>predict_epw_daily(fuel_type)</code>","text":"<p>Predict daily energy consumption using the regression model for a given fuel type.</p> <p>Uses the fitted regression model to estimate daily consumption for each day in the EPW weather file.</p> <p>Parameters:</p> Name Type Description Default <code>fuel_type</code> <code>FuelType</code> <p>The fuel type for which to predict daily consumption.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Array of predicted daily consumption values.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/inverse_model.py</code> <pre><code>def predict_epw_daily(self, fuel_type: FuelType) -&gt; pd.Series:\n    \"\"\"\n    Predict daily energy consumption using the regression model for a given fuel type.\n\n    Uses the fitted regression model to estimate daily consumption for each day in the EPW weather file.\n\n    :param fuel_type: The fuel type for which to predict daily consumption.\n    :type fuel_type: FuelType\n    :return: Array of predicted daily consumption values.\n    :rtype: np.ndarray\n    \"\"\"\n    model = self.get_model(fuel_type)\n    epw, _ = self.hpxml.get_epw_data(coerce_year=2007)\n    epw_daily_avg_temp = epw[\"temp_air\"].groupby(pd.Grouper(freq=\"D\")).mean() * 1.8 + 32\n    daily_predicted_fuel_use = model.predict_disaggregated(epw_daily_avg_temp.to_numpy())\n    return daily_predicted_fuel_use\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/","title":"Regression","text":""},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.Bpi2400ModelFitError","title":"<code>Bpi2400ModelFitError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the BPI-2400 regression model fit fails.</p> <p>Used to indicate that the regression model could not be fit with sufficient accuracy.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>class Bpi2400ModelFitError(Exception):\n    \"\"\"\n    Exception raised when the BPI-2400 regression model fit fails.\n\n    Used to indicate that the regression model could not be fit with sufficient accuracy.\n    \"\"\"\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.FiveParameter","title":"<code>FiveParameter</code>","text":"<p>               Bases: <code>UtilityBillRegressionModel</code></p> <p>5-parameter heating and cooling model from ASHRAE Guideline 14</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>class FiveParameter(UtilityBillRegressionModel):\n    \"\"\"5-parameter heating and cooling model from ASHRAE Guideline 14\"\"\"\n\n    MODEL_NAME = \"5-parameter\"\n\n    def __init__(self):\n        super().__init__()\n\n    def fit(self, bills_temps: pd.DataFrame) -&gt; None:\n        \"\"\"Fit the regression model to the heating and cooling billing and temperature data.\n\n        :param bills_temps: A dataframe containing heating and cooling billing and temperature data.\n        :type bills_temps: pd.DataFrame\n        \"\"\"\n        self.INITIAL_GUESSES = estimate_initial_guesses_5param(bills_temps)\n        self.BOUNDS = estimate_bounds_5param(bills_temps)\n        self.XSCALE = np.array([5000.0, 1000.0, 1000.0, 1.0, 1.0])\n\n        x = bills_temps[\"avg_temp\"].to_numpy()\n        y = bills_temps[\"daily_consumption\"].to_numpy()\n\n        def objective(params):\n            return np.sum((self.func(x, *params) - y) ** 2)\n\n        # Constrain the heating and cooling balance temps to differ by more than 5\n        # constraints = {\n        #     \"type\": \"ineq\",\n        #     \"fun\": lambda params: params[4] - params[3] - 5,\n        # }\n\n        bounds = list(zip(self.BOUNDS.lb, self.BOUNDS.ub))\n        result = minimize(\n            objective,\n            self.INITIAL_GUESSES,\n            method=\"trust-constr\",  # trust-constr supports both bounds and constraints\n            bounds=bounds,\n            # constraints=constraints,\n            options={\n                \"verbose\": 0,\n                \"maxiter\": 20000,\n            },\n        )\n        if not result.success:\n            raise RuntimeError(f\"Optimization failed: {result.message}\")\n\n        self.parameters = result.x\n        self.pcov = None  # scipy.optimize.minimize doesn't calculate it\n        self.cvrmse = self.calc_cvrmse(bills_temps)\n\n    def func(\n        self,\n        x: Sequence[float],\n        b1: float | np.floating,\n        b2: float | np.floating,\n        b3: float | np.floating,\n        b4: float | np.floating,\n        b5: float | np.floating,\n    ) -&gt; np.ndarray:\n        \"\"\"Model function for the 5-parameter heating and cooling model.\n\n        :param x: Independent variable, typically temperature.\n        :type x: Sequence[float] | np.ndarray\n        :param b1: Baseload consumption.\n        :type b1: float\n        :param b2: Heating slope.\n        :type b2: float\n        :param b3: Cooling slope.\n        :type b3: float\n        :param b4: Heating balance temperature.\n        :type b4: float\n        :param b5: Cooling balance temperature.\n        :type b5: float\n        :return: Dependent variable, typically energy consumption.\n        :rtype: np.ndarray\n        \"\"\"\n        x_arr = np.array(x)\n        return b1 + b2 * np.minimum(x_arr - b4, 0) + b3 * np.maximum(x_arr - b5, 0)\n\n    def predict_disaggregated(self, temperatures: Sequence[float] | np.ndarray) -&gt; pd.DataFrame:\n        \"\"\"Predict the disaggregated energy use for a given array of temperatures.\n\n        :param temperatures: An array of daily temperatures in degF.\n        :type temperatures: np.ndarray\n        :return: A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.\n        :rtype: np.ndarray\n        \"\"\"\n        temperatures_arr = np.array(temperatures)\n        b1, b2, b3, b4, b5 = self.parameters  # unpack the parameters\n        heating = b2 * np.minimum(temperatures_arr - b4, 0)\n        cooling = b3 * np.maximum(temperatures_arr - b5, 0)\n        baseload = np.ones_like(temperatures_arr, dtype=float) * b1\n        return pd.DataFrame({\"baseload\": baseload, \"heating\": heating, \"cooling\": cooling})\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.FiveParameter.fit","title":"<code>fit(bills_temps)</code>","text":"<p>Fit the regression model to the heating and cooling billing and temperature data.</p> <p>Parameters:</p> Name Type Description Default <code>bills_temps</code> <code>DataFrame</code> <p>A dataframe containing heating and cooling billing and temperature data.</p> required Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def fit(self, bills_temps: pd.DataFrame) -&gt; None:\n    \"\"\"Fit the regression model to the heating and cooling billing and temperature data.\n\n    :param bills_temps: A dataframe containing heating and cooling billing and temperature data.\n    :type bills_temps: pd.DataFrame\n    \"\"\"\n    self.INITIAL_GUESSES = estimate_initial_guesses_5param(bills_temps)\n    self.BOUNDS = estimate_bounds_5param(bills_temps)\n    self.XSCALE = np.array([5000.0, 1000.0, 1000.0, 1.0, 1.0])\n\n    x = bills_temps[\"avg_temp\"].to_numpy()\n    y = bills_temps[\"daily_consumption\"].to_numpy()\n\n    def objective(params):\n        return np.sum((self.func(x, *params) - y) ** 2)\n\n    # Constrain the heating and cooling balance temps to differ by more than 5\n    # constraints = {\n    #     \"type\": \"ineq\",\n    #     \"fun\": lambda params: params[4] - params[3] - 5,\n    # }\n\n    bounds = list(zip(self.BOUNDS.lb, self.BOUNDS.ub))\n    result = minimize(\n        objective,\n        self.INITIAL_GUESSES,\n        method=\"trust-constr\",  # trust-constr supports both bounds and constraints\n        bounds=bounds,\n        # constraints=constraints,\n        options={\n            \"verbose\": 0,\n            \"maxiter\": 20000,\n        },\n    )\n    if not result.success:\n        raise RuntimeError(f\"Optimization failed: {result.message}\")\n\n    self.parameters = result.x\n    self.pcov = None  # scipy.optimize.minimize doesn't calculate it\n    self.cvrmse = self.calc_cvrmse(bills_temps)\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.FiveParameter.func","title":"<code>func(x, b1, b2, b3, b4, b5)</code>","text":"<p>Model function for the 5-parameter heating and cooling model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float]</code> <p>Independent variable, typically temperature.</p> required <code>b1</code> <code>float | floating</code> <p>Baseload consumption.</p> required <code>b2</code> <code>float | floating</code> <p>Heating slope.</p> required <code>b3</code> <code>float | floating</code> <p>Cooling slope.</p> required <code>b4</code> <code>float | floating</code> <p>Heating balance temperature.</p> required <code>b5</code> <code>float | floating</code> <p>Cooling balance temperature.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Dependent variable, typically energy consumption.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def func(\n    self,\n    x: Sequence[float],\n    b1: float | np.floating,\n    b2: float | np.floating,\n    b3: float | np.floating,\n    b4: float | np.floating,\n    b5: float | np.floating,\n) -&gt; np.ndarray:\n    \"\"\"Model function for the 5-parameter heating and cooling model.\n\n    :param x: Independent variable, typically temperature.\n    :type x: Sequence[float] | np.ndarray\n    :param b1: Baseload consumption.\n    :type b1: float\n    :param b2: Heating slope.\n    :type b2: float\n    :param b3: Cooling slope.\n    :type b3: float\n    :param b4: Heating balance temperature.\n    :type b4: float\n    :param b5: Cooling balance temperature.\n    :type b5: float\n    :return: Dependent variable, typically energy consumption.\n    :rtype: np.ndarray\n    \"\"\"\n    x_arr = np.array(x)\n    return b1 + b2 * np.minimum(x_arr - b4, 0) + b3 * np.maximum(x_arr - b5, 0)\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.FiveParameter.predict_disaggregated","title":"<code>predict_disaggregated(temperatures)</code>","text":"<p>Predict the disaggregated energy use for a given array of temperatures.</p> <p>Parameters:</p> Name Type Description Default <code>temperatures</code> <code>Sequence[float] | ndarray</code> <p>An array of daily temperatures in degF.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def predict_disaggregated(self, temperatures: Sequence[float] | np.ndarray) -&gt; pd.DataFrame:\n    \"\"\"Predict the disaggregated energy use for a given array of temperatures.\n\n    :param temperatures: An array of daily temperatures in degF.\n    :type temperatures: np.ndarray\n    :return: A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.\n    :rtype: np.ndarray\n    \"\"\"\n    temperatures_arr = np.array(temperatures)\n    b1, b2, b3, b4, b5 = self.parameters  # unpack the parameters\n    heating = b2 * np.minimum(temperatures_arr - b4, 0)\n    cooling = b3 * np.maximum(temperatures_arr - b5, 0)\n    baseload = np.ones_like(temperatures_arr, dtype=float) * b1\n    return pd.DataFrame({\"baseload\": baseload, \"heating\": heating, \"cooling\": cooling})\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.ThreeParameterCooling","title":"<code>ThreeParameterCooling</code>","text":"<p>               Bases: <code>UtilityBillRegressionModel</code></p> <p>3-parameter cooling model from ASHRAE Guideline 14</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>class ThreeParameterCooling(UtilityBillRegressionModel):\n    \"\"\"3-parameter cooling model from ASHRAE Guideline 14\"\"\"\n\n    MODEL_NAME = \"3-parameter Cooling\"\n\n    def __init__(self):\n        super().__init__()\n\n    def fit(self, bills_temps: pd.DataFrame) -&gt; None:\n        \"\"\"Fit the regression model to the cooling billing and temperature data.\n\n        :param bills_temps: A dataframe containing cooling billing and temperature data.\n        :type bills_temps: pd.DataFrame\n        \"\"\"\n        self.INITIAL_GUESSES = estimate_initial_guesses_3param(\"cooling\", bills_temps)\n        self.BOUNDS = estimate_bounds_3param(\"cooling\", bills_temps)\n        self.XSCALE = np.array([5000.0, 1000.0, 1.0])\n        super().fit(bills_temps)\n\n    def func(\n        self,\n        x: Sequence[float] | np.ndarray,\n        b1: float | np.floating,\n        b2: float | np.floating,\n        b3: float | np.floating,\n    ) -&gt; np.ndarray:\n        \"\"\"Model function for the 3-parameter cooling model.\n\n        :param x: Independent variable, typically temperature.\n        :type x: Sequence[float] | np.ndarray\n        :param b1: Baseload consumption.\n        :type b1: float\n        :param b2: Cooling slope.\n        :type b2: float\n        :param b3: Balance temperature.\n        :type b3: float\n        :return: Dependent variable, typically energy consumption.\n        :rtype: np.ndarray\n        \"\"\"\n        x_arr = np.array(x)\n        return b1 + b2 * np.maximum(x_arr - b3, 0)\n\n    def predict_disaggregated(self, temperatures: Sequence[float] | np.ndarray) -&gt; pd.DataFrame:\n        \"\"\"Predict the disaggregated energy use for a given array of temperatures.\n\n        :param temperatures: An array of daily temperatures in degF.\n        :type temperatures: np.ndarray\n        :return: A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.\n        :rtype: np.ndarray\n        \"\"\"\n        temperatures_arr = np.array(temperatures)\n        b1, b2, b3 = self.parameters  # unpack the parameters\n        heating = np.zeros_like(temperatures_arr, dtype=float)\n        cooling = b2 * np.maximum(temperatures_arr - b3, 0)\n        baseload = np.ones_like(temperatures_arr, dtype=float) * b1\n        return pd.DataFrame({\"baseload\": baseload, \"heating\": heating, \"cooling\": cooling})\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.ThreeParameterCooling.fit","title":"<code>fit(bills_temps)</code>","text":"<p>Fit the regression model to the cooling billing and temperature data.</p> <p>Parameters:</p> Name Type Description Default <code>bills_temps</code> <code>DataFrame</code> <p>A dataframe containing cooling billing and temperature data.</p> required Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def fit(self, bills_temps: pd.DataFrame) -&gt; None:\n    \"\"\"Fit the regression model to the cooling billing and temperature data.\n\n    :param bills_temps: A dataframe containing cooling billing and temperature data.\n    :type bills_temps: pd.DataFrame\n    \"\"\"\n    self.INITIAL_GUESSES = estimate_initial_guesses_3param(\"cooling\", bills_temps)\n    self.BOUNDS = estimate_bounds_3param(\"cooling\", bills_temps)\n    self.XSCALE = np.array([5000.0, 1000.0, 1.0])\n    super().fit(bills_temps)\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.ThreeParameterCooling.func","title":"<code>func(x, b1, b2, b3)</code>","text":"<p>Model function for the 3-parameter cooling model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float] | ndarray</code> <p>Independent variable, typically temperature.</p> required <code>b1</code> <code>float | floating</code> <p>Baseload consumption.</p> required <code>b2</code> <code>float | floating</code> <p>Cooling slope.</p> required <code>b3</code> <code>float | floating</code> <p>Balance temperature.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Dependent variable, typically energy consumption.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def func(\n    self,\n    x: Sequence[float] | np.ndarray,\n    b1: float | np.floating,\n    b2: float | np.floating,\n    b3: float | np.floating,\n) -&gt; np.ndarray:\n    \"\"\"Model function for the 3-parameter cooling model.\n\n    :param x: Independent variable, typically temperature.\n    :type x: Sequence[float] | np.ndarray\n    :param b1: Baseload consumption.\n    :type b1: float\n    :param b2: Cooling slope.\n    :type b2: float\n    :param b3: Balance temperature.\n    :type b3: float\n    :return: Dependent variable, typically energy consumption.\n    :rtype: np.ndarray\n    \"\"\"\n    x_arr = np.array(x)\n    return b1 + b2 * np.maximum(x_arr - b3, 0)\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.ThreeParameterCooling.predict_disaggregated","title":"<code>predict_disaggregated(temperatures)</code>","text":"<p>Predict the disaggregated energy use for a given array of temperatures.</p> <p>Parameters:</p> Name Type Description Default <code>temperatures</code> <code>Sequence[float] | ndarray</code> <p>An array of daily temperatures in degF.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def predict_disaggregated(self, temperatures: Sequence[float] | np.ndarray) -&gt; pd.DataFrame:\n    \"\"\"Predict the disaggregated energy use for a given array of temperatures.\n\n    :param temperatures: An array of daily temperatures in degF.\n    :type temperatures: np.ndarray\n    :return: A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.\n    :rtype: np.ndarray\n    \"\"\"\n    temperatures_arr = np.array(temperatures)\n    b1, b2, b3 = self.parameters  # unpack the parameters\n    heating = np.zeros_like(temperatures_arr, dtype=float)\n    cooling = b2 * np.maximum(temperatures_arr - b3, 0)\n    baseload = np.ones_like(temperatures_arr, dtype=float) * b1\n    return pd.DataFrame({\"baseload\": baseload, \"heating\": heating, \"cooling\": cooling})\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.ThreeParameterHeating","title":"<code>ThreeParameterHeating</code>","text":"<p>               Bases: <code>UtilityBillRegressionModel</code></p> <p>3-parameter heating model from ASHRAE Guideline 14</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>class ThreeParameterHeating(UtilityBillRegressionModel):\n    \"\"\"3-parameter heating model from ASHRAE Guideline 14\"\"\"\n\n    MODEL_NAME = \"3-parameter Heating\"\n\n    def __init__(self):\n        super().__init__()\n\n    def fit(self, bills_temps: pd.DataFrame) -&gt; None:\n        \"\"\"Fit the regression model to the heating billing and temperature data.\n\n        :param bills_temps: A dataframe containing heating billing and temperature data.\n        :type bills_temps: pd.DataFrame\n        \"\"\"\n        self.INITIAL_GUESSES = estimate_initial_guesses_3param(\"heating\", bills_temps)\n        self.BOUNDS = estimate_bounds_3param(\"heating\", bills_temps)\n        self.XSCALE = np.array([5000.0, 1000.0, 1.0])\n        super().fit(bills_temps)\n\n    def func(\n        self,\n        x: Sequence[float],\n        b1: float | np.floating,\n        b2: float | np.floating,\n        b3: float | np.floating,\n    ) -&gt; np.ndarray:\n        \"\"\"Model function for the 3-parameter heating model.\n\n        :param x: Independent variable, typically temperature.\n        :type x: Sequence[float] | np.ndarray\n        :param b1: Baseload consumption.\n        :type b1: float\n        :param b2: Heating slope.\n        :type b2: float\n        :param b3: Balance temperature.\n        :type b3: float\n        :return: Dependent variable, typically energy consumption.\n        :rtype: np.ndarray\n        \"\"\"\n        x_arr = np.array(x)\n        return b1 + b2 * np.minimum(x_arr - b3, 0)\n\n    def predict_disaggregated(self, temperatures: Sequence[float] | np.ndarray) -&gt; pd.DataFrame:\n        \"\"\"Predict the disaggregated energy use for a given array of temperatures.\n\n        :param temperatures: An array of daily temperatures in degF.\n        :type temperatures: np.ndarray\n        :return: A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.\n        :rtype: np.ndarray\n        \"\"\"\n        temperatures_arr = np.array(temperatures)\n        b1, b2, b3 = self.parameters  # unpack the parameters\n        heating = b2 * np.minimum(temperatures_arr - b3, 0)\n        cooling = np.zeros_like(temperatures_arr, dtype=float)\n        baseload = np.ones_like(temperatures_arr, dtype=float) * b1\n        return pd.DataFrame({\"baseload\": baseload, \"heating\": heating, \"cooling\": cooling})\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.ThreeParameterHeating.fit","title":"<code>fit(bills_temps)</code>","text":"<p>Fit the regression model to the heating billing and temperature data.</p> <p>Parameters:</p> Name Type Description Default <code>bills_temps</code> <code>DataFrame</code> <p>A dataframe containing heating billing and temperature data.</p> required Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def fit(self, bills_temps: pd.DataFrame) -&gt; None:\n    \"\"\"Fit the regression model to the heating billing and temperature data.\n\n    :param bills_temps: A dataframe containing heating billing and temperature data.\n    :type bills_temps: pd.DataFrame\n    \"\"\"\n    self.INITIAL_GUESSES = estimate_initial_guesses_3param(\"heating\", bills_temps)\n    self.BOUNDS = estimate_bounds_3param(\"heating\", bills_temps)\n    self.XSCALE = np.array([5000.0, 1000.0, 1.0])\n    super().fit(bills_temps)\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.ThreeParameterHeating.func","title":"<code>func(x, b1, b2, b3)</code>","text":"<p>Model function for the 3-parameter heating model.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float]</code> <p>Independent variable, typically temperature.</p> required <code>b1</code> <code>float | floating</code> <p>Baseload consumption.</p> required <code>b2</code> <code>float | floating</code> <p>Heating slope.</p> required <code>b3</code> <code>float | floating</code> <p>Balance temperature.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Dependent variable, typically energy consumption.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def func(\n    self,\n    x: Sequence[float],\n    b1: float | np.floating,\n    b2: float | np.floating,\n    b3: float | np.floating,\n) -&gt; np.ndarray:\n    \"\"\"Model function for the 3-parameter heating model.\n\n    :param x: Independent variable, typically temperature.\n    :type x: Sequence[float] | np.ndarray\n    :param b1: Baseload consumption.\n    :type b1: float\n    :param b2: Heating slope.\n    :type b2: float\n    :param b3: Balance temperature.\n    :type b3: float\n    :return: Dependent variable, typically energy consumption.\n    :rtype: np.ndarray\n    \"\"\"\n    x_arr = np.array(x)\n    return b1 + b2 * np.minimum(x_arr - b3, 0)\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.ThreeParameterHeating.predict_disaggregated","title":"<code>predict_disaggregated(temperatures)</code>","text":"<p>Predict the disaggregated energy use for a given array of temperatures.</p> <p>Parameters:</p> Name Type Description Default <code>temperatures</code> <code>Sequence[float] | ndarray</code> <p>An array of daily temperatures in degF.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def predict_disaggregated(self, temperatures: Sequence[float] | np.ndarray) -&gt; pd.DataFrame:\n    \"\"\"Predict the disaggregated energy use for a given array of temperatures.\n\n    :param temperatures: An array of daily temperatures in degF.\n    :type temperatures: np.ndarray\n    :return: A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.\n    :rtype: np.ndarray\n    \"\"\"\n    temperatures_arr = np.array(temperatures)\n    b1, b2, b3 = self.parameters  # unpack the parameters\n    heating = b2 * np.minimum(temperatures_arr - b3, 0)\n    cooling = np.zeros_like(temperatures_arr, dtype=float)\n    baseload = np.ones_like(temperatures_arr, dtype=float) * b1\n    return pd.DataFrame({\"baseload\": baseload, \"heating\": heating, \"cooling\": cooling})\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.UtilityBillRegressionModel","title":"<code>UtilityBillRegressionModel</code>","text":"<p>Utility Bill Regression Model Base Class</p> <p>Implements a utility bill regression given the <code>bills_temps</code> dataframe.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>When it is called on the base class.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>class UtilityBillRegressionModel:\n    \"\"\"Utility Bill Regression Model Base Class\n\n    Implements a utility bill regression given the ``bills_temps`` dataframe.\n\n    :raises NotImplementedError: When it is called on the base class.\n    \"\"\"\n\n    MODEL_NAME: str = \"Base Model\"\n\n    def __init__(self):\n        self.parameters = None\n        self.pcov = None\n        self.INITIAL_GUESSES = []\n        self.BOUNDS = None\n        self.xscale = None\n\n    @property\n    def n_parameters(self) -&gt; int:\n        return len(self.INITIAL_GUESSES)\n\n    def fit(self, bills_temps: pd.DataFrame) -&gt; None:\n        \"\"\"Fit the regression model to the provided billing and temperature data.\n\n        This method estimates the model parameters that best fit the given data\n        using non-linear curve fitting.\n\n        :param bills_temps: A dataframe containing billing and temperature data.\n        :type bills_temps: pd.DataFrame\n        \"\"\"\n        popt, pcov = curve_fit(\n            self.func,\n            bills_temps[\"avg_temp\"].to_numpy(),\n            bills_temps[\"daily_consumption\"].to_numpy(),\n            p0=self.INITIAL_GUESSES,\n            bounds=self.BOUNDS,\n            method=\"trf\",\n            x_scale=self.XSCALE,\n        )\n        self.parameters = popt\n        self.pcov = pcov\n        self.cvrmse = self.calc_cvrmse(bills_temps)\n\n    def __call__(self, temperatures: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Given an array of temperatures [degF], return the predicted energy use.\n\n        This makes it so that an instance of this class can be called like a function.\n\n        :param temperatures: An array of daily temperatures in degF.\n        :type temperatures: np.ndarray\n        :return: An array of daily energy use, in the units the model was trained on.\n        :rtype: np.ndarray\n        \"\"\"\n        return self.func(temperatures, *self.parameters)\n\n    def predict_disaggregated(self, temperatures: Sequence[float] | np.ndarray) -&gt; pd.DataFrame:\n        \"\"\"Predict the disaggregated energy use for a given array of temperatures.\n\n        :param temperatures: An array of daily temperatures in degF.\n        :type temperatures: np.ndarray\n        :return: A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.\n        :rtype: np.ndarray\n        \"\"\"\n        raise NotImplementedError\n\n    def func(self, x: Sequence[float] | np.ndarray, *args: list[float | np.floating]) -&gt; np.ndarray:\n        \"\"\"Model function to be implemented by subclasses.\n\n        :param x: Independent variable, typically temperature.\n        :type x: Sequence[float] | np.ndarray\n        :param args: Model parameters.\n        :type args: list[float | np.floating]\n        :return: Dependent variable, typically energy consumption.\n        :rtype: np.ndarray\n        \"\"\"\n        raise NotImplementedError\n\n    def calc_cvrmse(self, bills_temps: pd.DataFrame) -&gt; float:\n        \"\"\"Calculate the CVRMSE for the model and the bills_temps dataframe.\n\n        :param bills_temps: A dataframe with bills and temperatures\n        :type bills_temps: pd.DataFrame\n        :return: Calculated CVRMSE\n        :rtype: float\n        \"\"\"\n        y = bills_temps[\"daily_consumption\"].to_numpy()\n        y_hat = self(bills_temps[\"avg_temp\"].to_numpy())\n        return np.sqrt(np.sum((y - y_hat) ** 2) / (y.shape[0] - self.n_parameters)) / y.mean()\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.UtilityBillRegressionModel.__call__","title":"<code>__call__(temperatures)</code>","text":"<p>Given an array of temperatures [degF], return the predicted energy use.</p> <p>This makes it so that an instance of this class can be called like a function.</p> <p>Parameters:</p> Name Type Description Default <code>temperatures</code> <code>ndarray</code> <p>An array of daily temperatures in degF.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>An array of daily energy use, in the units the model was trained on.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def __call__(self, temperatures: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Given an array of temperatures [degF], return the predicted energy use.\n\n    This makes it so that an instance of this class can be called like a function.\n\n    :param temperatures: An array of daily temperatures in degF.\n    :type temperatures: np.ndarray\n    :return: An array of daily energy use, in the units the model was trained on.\n    :rtype: np.ndarray\n    \"\"\"\n    return self.func(temperatures, *self.parameters)\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.UtilityBillRegressionModel.calc_cvrmse","title":"<code>calc_cvrmse(bills_temps)</code>","text":"<p>Calculate the CVRMSE for the model and the bills_temps dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>bills_temps</code> <code>DataFrame</code> <p>A dataframe with bills and temperatures</p> required <p>Returns:</p> Type Description <code>float</code> <p>Calculated CVRMSE</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def calc_cvrmse(self, bills_temps: pd.DataFrame) -&gt; float:\n    \"\"\"Calculate the CVRMSE for the model and the bills_temps dataframe.\n\n    :param bills_temps: A dataframe with bills and temperatures\n    :type bills_temps: pd.DataFrame\n    :return: Calculated CVRMSE\n    :rtype: float\n    \"\"\"\n    y = bills_temps[\"daily_consumption\"].to_numpy()\n    y_hat = self(bills_temps[\"avg_temp\"].to_numpy())\n    return np.sqrt(np.sum((y - y_hat) ** 2) / (y.shape[0] - self.n_parameters)) / y.mean()\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.UtilityBillRegressionModel.fit","title":"<code>fit(bills_temps)</code>","text":"<p>Fit the regression model to the provided billing and temperature data.</p> <p>This method estimates the model parameters that best fit the given data using non-linear curve fitting.</p> <p>Parameters:</p> Name Type Description Default <code>bills_temps</code> <code>DataFrame</code> <p>A dataframe containing billing and temperature data.</p> required Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def fit(self, bills_temps: pd.DataFrame) -&gt; None:\n    \"\"\"Fit the regression model to the provided billing and temperature data.\n\n    This method estimates the model parameters that best fit the given data\n    using non-linear curve fitting.\n\n    :param bills_temps: A dataframe containing billing and temperature data.\n    :type bills_temps: pd.DataFrame\n    \"\"\"\n    popt, pcov = curve_fit(\n        self.func,\n        bills_temps[\"avg_temp\"].to_numpy(),\n        bills_temps[\"daily_consumption\"].to_numpy(),\n        p0=self.INITIAL_GUESSES,\n        bounds=self.BOUNDS,\n        method=\"trf\",\n        x_scale=self.XSCALE,\n    )\n    self.parameters = popt\n    self.pcov = pcov\n    self.cvrmse = self.calc_cvrmse(bills_temps)\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.UtilityBillRegressionModel.func","title":"<code>func(x, *args)</code>","text":"<p>Model function to be implemented by subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float] | ndarray</code> <p>Independent variable, typically temperature.</p> required <code>args</code> <code>list[float | floating]</code> <p>Model parameters.</p> <code>()</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>Dependent variable, typically energy consumption.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def func(self, x: Sequence[float] | np.ndarray, *args: list[float | np.floating]) -&gt; np.ndarray:\n    \"\"\"Model function to be implemented by subclasses.\n\n    :param x: Independent variable, typically temperature.\n    :type x: Sequence[float] | np.ndarray\n    :param args: Model parameters.\n    :type args: list[float | np.floating]\n    :return: Dependent variable, typically energy consumption.\n    :rtype: np.ndarray\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.UtilityBillRegressionModel.predict_disaggregated","title":"<code>predict_disaggregated(temperatures)</code>","text":"<p>Predict the disaggregated energy use for a given array of temperatures.</p> <p>Parameters:</p> Name Type Description Default <code>temperatures</code> <code>Sequence[float] | ndarray</code> <p>An array of daily temperatures in degF.</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def predict_disaggregated(self, temperatures: Sequence[float] | np.ndarray) -&gt; pd.DataFrame:\n    \"\"\"Predict the disaggregated energy use for a given array of temperatures.\n\n    :param temperatures: An array of daily temperatures in degF.\n    :type temperatures: np.ndarray\n    :return: A dataframe with \"baseline\", \"heating\", and \"cooling\" columns.\n    :rtype: np.ndarray\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.estimate_bounds_3param","title":"<code>estimate_bounds_3param(model_type, bills_temps)</code>","text":"<p>Estimate the bounds for the parameters of the 3-parameter model.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>str</code> <p>Type of the model, either \"cooling\" or \"heating\".</p> required <code>bills_temps</code> <code>DataFrame</code> <p>A dataframe with bills and temperatures</p> required <p>Returns:</p> Type Description <code>Bounds</code> <p>Bounds object with lower and upper bounds for the model parameters.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the model type is unknown.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def estimate_bounds_3param(model_type: str, bills_temps: pd.DataFrame) -&gt; Bounds:\n    \"\"\"Estimate the bounds for the parameters of the 3-parameter model.\n\n    :param model_type: Type of the model, either \"cooling\" or \"heating\".\n    :type model_type: str\n    :param bills_temps: A dataframe with bills and temperatures\n    :type bills_temps: pd.DataFrame\n    :return: Bounds object with lower and upper bounds for the model parameters.\n    :rtype: Bounds\n    :raises ValueError: If the model type is unknown.\n    \"\"\"\n    usage = bills_temps[\"daily_consumption\"].to_numpy()\n    baseload_lb = np.min(usage)\n\n    # TODO: Improve slope bounds\n    if model_type == \"heating\":\n        return Bounds(lb=[baseload_lb, -np.inf, 30.0], ub=[np.inf, 0.0, 75.0])\n    elif model_type == \"cooling\":\n        return Bounds(lb=[baseload_lb, 0.0, 30.0], ub=[np.inf, np.inf, 75.0])\n    else:\n        raise ValueError(\"Unknown model type\")\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.estimate_bounds_5param","title":"<code>estimate_bounds_5param(bills_temps)</code>","text":"<p>Estimate the bounds for the parameters of the 5-parameter model.</p> <p>Parameters:</p> Name Type Description Default <code>bills_temps</code> <code>DataFrame</code> <p>A dataframe with bills and temperatures</p> required <p>Returns:</p> Type Description <code>Bounds</code> <p>Bounds object with lower and upper bounds for the model parameters.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def estimate_bounds_5param(bills_temps: pd.DataFrame) -&gt; Bounds:\n    \"\"\"Estimate the bounds for the parameters of the 5-parameter model.\n\n    :param bills_temps: A dataframe with bills and temperatures\n    :type bills_temps: pd.DataFrame\n    :return: Bounds object with lower and upper bounds for the model parameters.\n    :rtype: Bounds\n    \"\"\"\n    usage = bills_temps[\"daily_consumption\"].to_numpy()\n    baseload_lb = np.min(usage)\n\n    # TODO: Improve slope bounds\n    return Bounds(\n        lb=[baseload_lb, -np.inf, 0.0, 30.0, 30.0],\n        ub=[np.inf, 0.0, np.inf, 75.0, 75.0],\n    )\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.estimate_initial_guesses_3param","title":"<code>estimate_initial_guesses_3param(model_type, bills_temps)</code>","text":"<p>Estimate initial guesses for the parameters of the 3-parameter model.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>str</code> <p>Type of the model, either \"cooling\" or \"heating\".</p> required <code>bills_temps</code> <code>DataFrame</code> <p>A dataframe with bills and temperatures</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>List of initial guesses for the model parameters.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the model type is unknown.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def estimate_initial_guesses_3param(model_type: str, bills_temps: pd.DataFrame) -&gt; list[float]:\n    \"\"\"Estimate initial guesses for the parameters of the 3-parameter model.\n\n    :param model_type: Type of the model, either \"cooling\" or \"heating\".\n    :type model_type: str\n    :param bills_temps: A dataframe with bills and temperatures\n    :type bills_temps: pd.DataFrame\n    :return: List of initial guesses for the model parameters.\n    :rtype: list[float]\n    :raises ValueError: If the model type is unknown.\n    \"\"\"\n    temps = bills_temps[\"avg_temp\"].to_numpy()\n    usage = bills_temps[\"daily_consumption\"].to_numpy()\n    # Estimate baseload by taking the 10th percentile of usage data\n    b1 = np.percentile(usage, 10)  # TODO: There might be a better way to estimate baseload\n\n    if model_type == \"cooling\":\n        b3 = 65  # TODO: There might be a better way to estimate balance temperature\n        slope = (np.max(usage) - b1) / (np.max(temps) - b3 + 1e-6)\n        b2 = max(slope, 1.0)\n\n        return [b1, b2, b3]\n\n    elif model_type == \"heating\":\n        b3 = 65  # TODO: There might be a better way to estimate balance temperature\n        slope = (np.max(usage) - b1) / (b3 - np.min(temps) + 1e-6)\n        b2 = -abs(slope)\n\n        return [b1, b2, b3]\n\n    else:\n        raise ValueError(\"Unknown model type\")\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.estimate_initial_guesses_5param","title":"<code>estimate_initial_guesses_5param(bills_temps)</code>","text":"<p>Estimate initial guesses for the parameters of the 5-parameter model.</p> <p>Parameters:</p> Name Type Description Default <code>bills_temps</code> <code>DataFrame</code> <p>A dataframe with bills and temperatures</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>List of initial guesses for the model parameters.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def estimate_initial_guesses_5param(bills_temps: pd.DataFrame) -&gt; list[float]:\n    \"\"\"Estimate initial guesses for the parameters of the 5-parameter model.\n\n    :param bills_temps: A dataframe with bills and temperatures\n    :type bills_temps: pd.DataFrame\n    :return: List of initial guesses for the model parameters.\n    :rtype: list[float]\n    \"\"\"\n    temps = bills_temps[\"avg_temp\"].to_numpy()\n    usage = bills_temps[\"daily_consumption\"].to_numpy()\n    # Estimate baseload by taking the 10th percentile of usage data\n    b1 = np.percentile(usage, 10)  # TODO: There might be a better way to estimate baseload\n\n    # Heating slope (b2) and balance temperature (b4)\n    select_cold_temps = temps &lt;= np.median(temps)\n    cold_temps = temps[select_cold_temps]\n    cold_usage = usage[select_cold_temps]\n    b4 = 55  # TODO: There might be a better way to estimate balance point\n    heating_slope = -abs((np.max(cold_usage) - b1) / (b4 - np.min(cold_temps) + 1e-6))\n    b2 = heating_slope\n\n    # Cooling slope (b3) and balance temperature\n    select_hot_temps = temps &gt;= np.median(temps)\n    hot_temps = temps[select_hot_temps]\n    hot_usage = usage[select_hot_temps]\n    b5 = 65  # TODO: There might be a better way to estimate balance point\n    cooling_slope = max((np.max(hot_usage) - b1) / (np.max(hot_temps) - b5 + 1e-6), 1.0)\n    b3 = cooling_slope\n\n    return [b1, b2, b3, b4, b5]\n</code></pre>"},{"location":"code_documentation/weather_normalization/regression/#src.openstudio_hpxml_calibration.weather_normalization.regression.fit_model","title":"<code>fit_model(bills_temps, cvrmse_requirement, conditioning_fuels, fuel_type)</code>","text":"<p>Fit a regression model to the utility bills</p> <p>The <code>bills_temps</code> dataframe should be in the format returned by the <code>utility_data.join_bills_weather</code> function. At a minimum this should include the columns \"daily_consumption\" and \"avg_temp\" in degF. The index is ignored.</p> <p>Parameters:</p> Name Type Description Default <code>bills_temps</code> <code>DataFrame</code> <p>dataframe of utility bills and temperatures.</p> required <code>cvrmse_requirement</code> <code>float</code> <p>CVRMSE requirement for model selection.</p> required <p>Returns:</p> Type Description <code>UtilityBillRegressionModel</code> <p>An instance of a model class, fit to your data.</p> <p>Raises:</p> Type Description <code>Bpi2400ModelFitError</code> <p>Error thrown if model doesn't meet BPI-2400 criteria</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/regression.py</code> <pre><code>def fit_model(\n    bills_temps: pd.DataFrame,\n    cvrmse_requirement: float,\n    conditioning_fuels: set,\n    fuel_type: FuelType,\n) -&gt; UtilityBillRegressionModel:\n    \"\"\"Fit a regression model to the utility bills\n\n    The ``bills_temps`` dataframe should be in the format returned by the\n    ``utility_data.join_bills_weather`` function. At a minimum this should\n    include the columns \"daily_consumption\" and \"avg_temp\" in degF. The index is\n    ignored.\n\n    :param bills_temps: dataframe of utility bills and temperatures.\n    :type bills_temps: pd.DataFrame\n    :param cvrmse_requirement: CVRMSE requirement for model selection.\n    :type cvrmse_requirement: float\n    :raises Bpi2400ModelFitError: Error thrown if model doesn't meet BPI-2400\n        criteria\n    :return: An instance of a model class, fit to your data.\n    :rtype: UtilityBillRegressionModel\n    \"\"\"\n    models_to_try = [ThreeParameterCooling, ThreeParameterHeating, FiveParameter]\n    models = []\n    for ModelClass in models_to_try:\n        model = ModelClass()\n        try:\n            model.fit(bills_temps)\n            models.append(model)\n        except RuntimeError as ex:\n            if (\n                str(ex)\n                == \"Optimal parameters not found: The maximum number of function evaluations is exceeded.\"\n            ):\n                warnings.warn(f\"Unable to fit {ModelClass.MODEL_NAME} to data.\")\n                continue\n            else:\n                raise\n    best_model = min(models, key=lambda x: x.cvrmse)\n    if fuel_type.value in conditioning_fuels and (cvrmse := best_model.cvrmse) &gt; cvrmse_requirement:\n        raise Bpi2400ModelFitError(\n            f\"CVRMSE = {cvrmse:0.1%} for {fuel_type.value}, which is greater than {cvrmse_requirement:0.1%}\"\n        )\n    return best_model\n</code></pre>"},{"location":"code_documentation/weather_normalization/utility_data/","title":"Utility Data","text":""},{"location":"code_documentation/weather_normalization/utility_data/#src.openstudio_hpxml_calibration.weather_normalization.utility_data.get_bills_from_hpxml","title":"<code>get_bills_from_hpxml(hpxml, building_id=None)</code>","text":"<p>Get utility bills from an HPXML file.</p> <p>Parameters:</p> Name Type Description Default <code>hpxml</code> <code>HpxmlDoc</code> <p>The HPXML file</p> required <code>building_id</code> <code>str | None</code> <p>Optional building_id of the building you want to get bills for.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[dict[FuelType, pd.DataFrame], dict[FuelType, EnergyUnitType], dt.timezone]</code> <ul> <li><code>bills_by_fuel_type</code>, a dictionary with fuel types as the keys and a dataframe as the values with columns <code>start_date</code>, <code>end_date</code>, and <code>consumption</code> * <code>bill_units</code>, a dictionary with a map of fuel type to units in the HPXML file. * <code>local_standard_tz</code>, the timezone (standard, no DST) of the location.</li> </ul> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/utility_data.py</code> <pre><code>def get_bills_from_hpxml(\n    hpxml: HpxmlDoc, building_id: str | None = None\n) -&gt; tuple[dict[FuelType, pd.DataFrame], dict[FuelType, EnergyUnitType], dt.timezone]:\n    \"\"\"Get utility bills from an HPXML file.\n\n    :param hpxml: The HPXML file\n    :type hpxml: HpxmlDoc\n    :param building_id: Optional building_id of the building you want to get bills for.\n    :type building_id: str | None\n    :return:\n        * `bills_by_fuel_type`, a dictionary with fuel types as the keys and a\n          dataframe as the values with columns `start_date`, `end_date`, and `consumption`\n        * `bill_units`, a dictionary with a map of fuel type to units in the HPXML file.\n        * `local_standard_tz`, the timezone (standard, no DST) of the location.\n    :rtype: tuple[dict[FuelType, pd.DataFrame], dict[FuelType, EnergyUnitType], dt.timezone]\n    \"\"\"\n    if building_id is None:\n        building_id = hpxml.get_first_building_id()\n    building = hpxml.get_building(building_id)\n    try:\n        utc_offset = int(building.Site.TimeZone.UTCOffset)\n    except AttributeError:\n        _, epw_metadata = hpxml.get_epw_data(building_id)\n        utc_offset = epw_metadata[\"TZ\"]\n\n    local_standard_tz = dt.timezone(dt.timedelta(hours=utc_offset))\n\n    bills_by_fuel_type = {}\n    bill_units = {}\n\n    consumptions = hpxml.xpath(\n        \"h:Consumption[h:BuildingID/@idref=$building_id]\",\n        building_id=building_id,\n    )\n    if not consumptions:\n        raise ValueError(\n            f\"No matching Consumption/BuildingID/@idref equal to Building/BuildingID/@id={building_id} was found in HPXML.\"\n        )\n    for consumption in consumptions:\n        cons_infos = consumption.xpath(\n            \"h:ConsumptionDetails/h:ConsumptionInfo\", namespaces=hpxml.ns\n        )\n        for cons_info in cons_infos:\n            fuel_type = FuelType(cons_info.ConsumptionType.Energy.FuelType)\n            bill_units[fuel_type] = EnergyUnitType(cons_info.ConsumptionType.Energy.UnitofMeasure)\n            rows = []\n            for el in cons_info.ConsumptionDetail:\n                rows.append(\n                    [\n                        get_datetime_subel(el, \"StartDateTime\"),\n                        get_datetime_subel(el, \"EndDateTime\"),\n                        float(el.Consumption),\n                    ]\n                )\n            bills = pd.DataFrame.from_records(\n                rows, columns=[\"start_date\", \"end_date\", \"consumption\"]\n            )\n            if pd.isna(bills[\"end_date\"]).all():\n                bills[\"end_date\"] = bills[\"start_date\"].shift(-1)\n            if pd.isna(bills[\"start_date\"]).all():\n                bills[\"start_date\"] = bills[\"end_date\"].shift(1)\n\n            bills[\"start_day_of_year\"] = bills[\"start_date\"].dt.dayofyear\n            # Subtract 1 from end day because the bill shows it at hour 00:00 of the end date\n            bills[\"end_day_of_year\"] = bills[\"end_date\"].dt.dayofyear - 1\n\n            bills[\"start_date\"] = bills[\"start_date\"].dt.tz_localize(local_standard_tz)\n            bills[\"end_date\"] = bills[\"end_date\"].dt.tz_localize(local_standard_tz)\n            bills_by_fuel_type[fuel_type] = bills\n\n    return bills_by_fuel_type, bill_units, local_standard_tz\n</code></pre>"},{"location":"code_documentation/weather_normalization/utility_data/#src.openstudio_hpxml_calibration.weather_normalization.utility_data.join_bills_weather","title":"<code>join_bills_weather(bills_orig, lat, lon, **kw)</code>","text":"<p>Join the bills dataframe with an average daily temperature</p> <p>Parameters:</p> Name Type Description Default <code>bills_orig</code> <code>DataFrame</code> <p>Dataframe with columns <code>start_date</code>, <code>end_date</code>, and <code>consumption</code> representing each bill period.</p> required <code>lat</code> <code>float</code> <p>latitude of building</p> required <code>lon</code> <code>float</code> <p>longitude of building</p> required <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>An augmented bills dataframe with additional <code>daily_consumption</code>, <code>n_days</code>, and <code>avg_temp</code> columns.</p> Source code in <code>src/openstudio_hpxml_calibration/weather_normalization/utility_data.py</code> <pre><code>def join_bills_weather(bills_orig: pd.DataFrame, lat: float, lon: float, **kw) -&gt; pd.DataFrame:\n    \"\"\"Join the bills dataframe with an average daily temperature\n\n    :param bills_orig: Dataframe with columns `start_date`, `end_date`, and `consumption` representing each bill period.\n    :type bills_orig: pd.DataFrame\n    :param lat: latitude of building\n    :type lat: float\n    :param lon: longitude of building\n    :type lon: float\n    :return: An augmented bills dataframe with additional `daily_consumption`, `n_days`, and `avg_temp` columns.\n    :rtype: pd.DataFrame\n    \"\"\"\n    start_date = bills_orig[\"start_date\"].min().tz_convert(\"UTC\")\n    end_date = bills_orig[\"end_date\"].max().tz_convert(\"UTC\")\n    rank_stations_kw = {\"minimum_quality\": \"medium\"}\n    rank_stations_kw.update(kw)\n    with warnings.catch_warnings():\n        ranked_stations = eeweather.rank_stations(lat, lon, **rank_stations_kw)\n        isd_station, _ = eeweather.select_station(\n            ranked_stations, coverage_range=(start_date, end_date)\n        )\n        tempC, _ = isd_station.load_isd_hourly_temp_data(start_date, end_date)\n    tempC = tempC.tz_convert(bills_orig[\"start_date\"].dt.tz)\n    tempF = convert_units(tempC, \"c\", \"f\")\n    bills = bills_orig.copy()\n    bills[\"n_days\"] = (\n        (bills_orig[\"end_date\"] - bills_orig[\"start_date\"]).dt.total_seconds() / 60 / 60 / 24\n    )\n    bills[\"daily_consumption\"] = bills[\"consumption\"] / bills[\"n_days\"]\n\n    bills = bills.replace([np.inf, -np.inf], np.nan).dropna().copy()\n\n    bill_avg_temps = []\n    for _, row in bills.iterrows():\n        bill_temps = tempF[row[\"start_date\"] : row[\"end_date\"]]\n        if bill_temps.empty:\n            bill_avg_temps.append(None)\n        else:\n            bill_avg_temps.append(bill_temps.mean())\n    bills[\"avg_temp\"] = bill_avg_temps\n    return bills, tempF\n</code></pre>"}]}